ARM GAS  /tmp/ccyWPqe2.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"os_mutex.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.OSMutex_RdyAtPrio,"ax",%progbits
  18              		.align	1
  19              		.arch armv7e-m
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	OSMutex_RdyAtPrio:
  26              	.LVL0:
  27              	.LFB6:
  28              		.file 1 "uCOSII/Source/os_mutex.c"
   1:uCOSII/Source/os_mutex.c **** /*
   2:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
   3:uCOSII/Source/os_mutex.c **** *                                                uC/OS-II
   4:uCOSII/Source/os_mutex.c **** *                                          The Real-Time Kernel
   5:uCOSII/Source/os_mutex.c **** *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
   6:uCOSII/Source/os_mutex.c **** *
   7:uCOSII/Source/os_mutex.c **** *                              (c) Copyright 1992-2013, Micrium, Weston, FL
   8:uCOSII/Source/os_mutex.c **** *                                           All Rights Reserved
   9:uCOSII/Source/os_mutex.c **** *
  10:uCOSII/Source/os_mutex.c **** * File    : OS_MUTEX.C
  11:uCOSII/Source/os_mutex.c **** * By      : Jean J. Labrosse
  12:uCOSII/Source/os_mutex.c **** * Version : V2.92.11
  13:uCOSII/Source/os_mutex.c **** *
  14:uCOSII/Source/os_mutex.c **** * LICENSING TERMS:
  15:uCOSII/Source/os_mutex.c **** * ---------------
  16:uCOSII/Source/os_mutex.c **** *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful re
  17:uCOSII/Source/os_mutex.c **** * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly l
  18:uCOSII/Source/os_mutex.c **** * its use in your product. We provide ALL the source code for your convenience and to help you expe
  19:uCOSII/Source/os_mutex.c **** * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  pa
  20:uCOSII/Source/os_mutex.c **** * licensing fee.
  21:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  22:uCOSII/Source/os_mutex.c **** */
  23:uCOSII/Source/os_mutex.c **** 
  24:uCOSII/Source/os_mutex.c **** #define  MICRIUM_SOURCE
  25:uCOSII/Source/os_mutex.c **** 
  26:uCOSII/Source/os_mutex.c **** #ifndef  OS_MASTER_FILE
  27:uCOSII/Source/os_mutex.c **** #include <ucos_ii.h>
  28:uCOSII/Source/os_mutex.c **** #endif
  29:uCOSII/Source/os_mutex.c **** 
  30:uCOSII/Source/os_mutex.c **** 
ARM GAS  /tmp/ccyWPqe2.s 			page 2


  31:uCOSII/Source/os_mutex.c **** #if OS_MUTEX_EN > 0u
  32:uCOSII/Source/os_mutex.c **** /*
  33:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  34:uCOSII/Source/os_mutex.c **** *                                           LOCAL CONSTANTS
  35:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  36:uCOSII/Source/os_mutex.c **** */
  37:uCOSII/Source/os_mutex.c **** 
  38:uCOSII/Source/os_mutex.c **** #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
  39:uCOSII/Source/os_mutex.c **** #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
  40:uCOSII/Source/os_mutex.c **** 
  41:uCOSII/Source/os_mutex.c **** #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
  42:uCOSII/Source/os_mutex.c **** 
  43:uCOSII/Source/os_mutex.c **** /*
  44:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  45:uCOSII/Source/os_mutex.c **** *                                           LOCAL CONSTANTS
  46:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  47:uCOSII/Source/os_mutex.c **** */
  48:uCOSII/Source/os_mutex.c **** 
  49:uCOSII/Source/os_mutex.c **** static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
  50:uCOSII/Source/os_mutex.c **** 
  51:uCOSII/Source/os_mutex.c **** /*$PAGE*/
  52:uCOSII/Source/os_mutex.c **** /*
  53:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  54:uCOSII/Source/os_mutex.c **** *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
  55:uCOSII/Source/os_mutex.c **** *
  56:uCOSII/Source/os_mutex.c **** * Description: This  function checks the mutual exclusion semaphore to see if a resource is availab
  57:uCOSII/Source/os_mutex.c **** *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resou
  58:uCOSII/Source/os_mutex.c **** *              not available or the event did not occur.
  59:uCOSII/Source/os_mutex.c **** *
  60:uCOSII/Source/os_mutex.c **** * Arguments  : pevent     is a pointer to the event control block
  61:uCOSII/Source/os_mutex.c **** *
  62:uCOSII/Source/os_mutex.c **** *              perr       is a pointer to an error code which will be returned to your application:
  63:uCOSII/Source/os_mutex.c **** *                            OS_ERR_NONE         if the call was successful.
  64:uCOSII/Source/os_mutex.c **** *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
  65:uCOSII/Source/os_mutex.c **** *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
  66:uCOSII/Source/os_mutex.c **** *                            OS_ERR_PEND_ISR     if you called this function from an ISR
  67:uCOSII/Source/os_mutex.c **** *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
  68:uCOSII/Source/os_mutex.c **** *                                                HIGHER (i.e. a lower number) than the PCP.  This e
  69:uCOSII/Source/os_mutex.c **** *                                                indicates that you did not set the PCP higher (low
  70:uCOSII/Source/os_mutex.c **** *                                                number) than ALL the tasks that compete for the Mu
  71:uCOSII/Source/os_mutex.c **** *                                                Unfortunately, this is something that could not be
  72:uCOSII/Source/os_mutex.c **** *                                                detected when the Mutex is created because we don'
  73:uCOSII/Source/os_mutex.c **** *                                                what tasks will be using the Mutex.
  74:uCOSII/Source/os_mutex.c **** *
  75:uCOSII/Source/os_mutex.c **** * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquir
  76:uCOSII/Source/os_mutex.c **** *              == OS_FALSE   a) if the resource is not available
  77:uCOSII/Source/os_mutex.c **** *                            b) you didn't pass a pointer to a mutual exclusion semaphore
  78:uCOSII/Source/os_mutex.c **** *                            c) you called this function from an ISR
  79:uCOSII/Source/os_mutex.c **** *
  80:uCOSII/Source/os_mutex.c **** * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
  81:uCOSII/Source/os_mutex.c **** *              intended to be used by tasks only.
  82:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
  83:uCOSII/Source/os_mutex.c **** */
  84:uCOSII/Source/os_mutex.c **** 
  85:uCOSII/Source/os_mutex.c **** #if OS_MUTEX_ACCEPT_EN > 0u
  86:uCOSII/Source/os_mutex.c **** BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
  87:uCOSII/Source/os_mutex.c ****                         INT8U     *perr)
ARM GAS  /tmp/ccyWPqe2.s 			page 3


  88:uCOSII/Source/os_mutex.c **** {
  89:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)          
  90:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register 
  91:uCOSII/Source/os_mutex.c ****     OS_CPU_SR  cpu_sr = 0u;
  92:uCOSII/Source/os_mutex.c **** #endif
  93:uCOSII/Source/os_mutex.c **** 
  94:uCOSII/Source/os_mutex.c **** 
  95:uCOSII/Source/os_mutex.c **** 
  96:uCOSII/Source/os_mutex.c **** #ifdef OS_SAFETY_CRITICAL
  97:uCOSII/Source/os_mutex.c ****     if (perr == (INT8U *)0) {
  98:uCOSII/Source/os_mutex.c ****         OS_SAFETY_CRITICAL_EXCEPTION();
  99:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 100:uCOSII/Source/os_mutex.c ****     }
 101:uCOSII/Source/os_mutex.c **** #endif
 102:uCOSII/Source/os_mutex.c **** 
 103:uCOSII/Source/os_mutex.c **** #if OS_ARG_CHK_EN > 0u
 104:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                        
 105:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEVENT_NULL;
 106:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 107:uCOSII/Source/os_mutex.c ****     }
 108:uCOSII/Source/os_mutex.c **** #endif
 109:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                
 110:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 111:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 112:uCOSII/Source/os_mutex.c ****     }
 113:uCOSII/Source/os_mutex.c ****     if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR    
 114:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;
 115:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 116:uCOSII/Source/os_mutex.c ****     }
 117:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex              
 118:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                       
 119:uCOSII/Source/os_mutex.c ****     if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 120:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)     
 121:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte
 122:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex       
 123:uCOSII/Source/os_mutex.c ****         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
 124:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...  
 125:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();                       /*      ... than current task!              
 126:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_PCP_LOWER;
 127:uCOSII/Source/os_mutex.c ****         } else {
 128:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();
 129:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_NONE;
 130:uCOSII/Source/os_mutex.c ****         }
 131:uCOSII/Source/os_mutex.c ****         return (OS_TRUE);
 132:uCOSII/Source/os_mutex.c ****     }
 133:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 134:uCOSII/Source/os_mutex.c ****     *perr = OS_ERR_NONE;
 135:uCOSII/Source/os_mutex.c ****     return (OS_FALSE);
 136:uCOSII/Source/os_mutex.c **** }
 137:uCOSII/Source/os_mutex.c **** #endif
 138:uCOSII/Source/os_mutex.c **** 
 139:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 140:uCOSII/Source/os_mutex.c **** /*
 141:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 142:uCOSII/Source/os_mutex.c **** *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
 143:uCOSII/Source/os_mutex.c **** *
 144:uCOSII/Source/os_mutex.c **** * Description: This function creates a mutual exclusion semaphore.
ARM GAS  /tmp/ccyWPqe2.s 			page 4


 145:uCOSII/Source/os_mutex.c **** *
 146:uCOSII/Source/os_mutex.c **** * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore. 
 147:uCOSII/Source/os_mutex.c **** *                            other words, when the semaphore is acquired and a higher priority task
 148:uCOSII/Source/os_mutex.c **** *                            attempts to obtain the semaphore then the priority of the task owning 
 149:uCOSII/Source/os_mutex.c **** *                            semaphore is raised to this priority.  It is assumed that you will spe
 150:uCOSII/Source/os_mutex.c **** *                            a priority that is LOWER in value than ANY of the tasks competing for 
 151:uCOSII/Source/os_mutex.c **** *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then th
 152:uCOSII/Source/os_mutex.c **** *                            priority ceiling promotion is disabled. This way, the tasks accessing 
 153:uCOSII/Source/os_mutex.c **** *                            semaphore do not have their priority promoted.
 154:uCOSII/Source/os_mutex.c **** *
 155:uCOSII/Source/os_mutex.c **** *              perr          is a pointer to an error code which will be returned to your applicati
 156:uCOSII/Source/os_mutex.c **** *                               OS_ERR_NONE         if the call was successful.
 157:uCOSII/Source/os_mutex.c **** *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
 158:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
 159:uCOSII/Source/os_mutex.c **** *                                                   already exist.
 160:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
 161:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
 162:uCOSII/Source/os_mutex.c **** *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
 163:uCOSII/Source/os_mutex.c **** *
 164:uCOSII/Source/os_mutex.c **** * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
 165:uCOSII/Source/os_mutex.c **** *                            created mutex.
 166:uCOSII/Source/os_mutex.c **** *              == (void *)0  if an error is detected.
 167:uCOSII/Source/os_mutex.c **** *
 168:uCOSII/Source/os_mutex.c **** * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the tas
 169:uCOSII/Source/os_mutex.c **** *                 owning the mutex or 0xFF if no task owns the mutex.
 170:uCOSII/Source/os_mutex.c **** *
 171:uCOSII/Source/os_mutex.c **** *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
 172:uCOSII/Source/os_mutex.c **** *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
 173:uCOSII/Source/os_mutex.c **** *                 promotion is disabled.
 174:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 175:uCOSII/Source/os_mutex.c **** */
 176:uCOSII/Source/os_mutex.c **** 
 177:uCOSII/Source/os_mutex.c **** OS_EVENT  *OSMutexCreate (INT8U   prio,
 178:uCOSII/Source/os_mutex.c ****                           INT8U  *perr)
 179:uCOSII/Source/os_mutex.c **** {
 180:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent;
 181:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status regis
 182:uCOSII/Source/os_mutex.c ****     OS_CPU_SR  cpu_sr = 0u;
 183:uCOSII/Source/os_mutex.c **** #endif
 184:uCOSII/Source/os_mutex.c **** 
 185:uCOSII/Source/os_mutex.c **** 
 186:uCOSII/Source/os_mutex.c **** 
 187:uCOSII/Source/os_mutex.c **** #ifdef OS_SAFETY_CRITICAL
 188:uCOSII/Source/os_mutex.c ****     if (perr == (INT8U *)0) {
 189:uCOSII/Source/os_mutex.c ****         OS_SAFETY_CRITICAL_EXCEPTION();
 190:uCOSII/Source/os_mutex.c ****         return ((OS_EVENT *)0);
 191:uCOSII/Source/os_mutex.c ****     }
 192:uCOSII/Source/os_mutex.c **** #endif
 193:uCOSII/Source/os_mutex.c **** 
 194:uCOSII/Source/os_mutex.c **** #ifdef OS_SAFETY_CRITICAL_IEC61508
 195:uCOSII/Source/os_mutex.c ****     if (OSSafetyCriticalStartFlag == OS_TRUE) {
 196:uCOSII/Source/os_mutex.c ****         OS_SAFETY_CRITICAL_EXCEPTION();
 197:uCOSII/Source/os_mutex.c ****         return ((OS_EVENT *)0);
 198:uCOSII/Source/os_mutex.c ****     }
 199:uCOSII/Source/os_mutex.c **** #endif
 200:uCOSII/Source/os_mutex.c **** 
 201:uCOSII/Source/os_mutex.c **** #if OS_ARG_CHK_EN > 0u
ARM GAS  /tmp/ccyWPqe2.s 			page 5


 202:uCOSII/Source/os_mutex.c ****     if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 203:uCOSII/Source/os_mutex.c ****         if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                         
 204:uCOSII/Source/os_mutex.c ****            *perr = OS_ERR_PRIO_INVALID;
 205:uCOSII/Source/os_mutex.c ****             return ((OS_EVENT *)0);
 206:uCOSII/Source/os_mutex.c ****         }
 207:uCOSII/Source/os_mutex.c ****     }
 208:uCOSII/Source/os_mutex.c **** #endif
 209:uCOSII/Source/os_mutex.c ****     if (OSIntNesting > 0u) {                               /* See if called from ISR ...           
 210:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR   
 211:uCOSII/Source/os_mutex.c ****         return ((OS_EVENT *)0);
 212:uCOSII/Source/os_mutex.c ****     }
 213:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 214:uCOSII/Source/os_mutex.c ****     if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 215:uCOSII/Source/os_mutex.c ****         if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist
 216:uCOSII/Source/os_mutex.c ****             OS_EXIT_CRITICAL();                            /* Task already exist at priority ...   
 217:uCOSII/Source/os_mutex.c ****            *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                 
 218:uCOSII/Source/os_mutex.c ****             return ((OS_EVENT *)0);
 219:uCOSII/Source/os_mutex.c ****         }
 220:uCOSII/Source/os_mutex.c ****         OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry              
 221:uCOSII/Source/os_mutex.c ****     }
 222:uCOSII/Source/os_mutex.c **** 
 223:uCOSII/Source/os_mutex.c ****     pevent = OSEventFreeList;                              /* Get next free event control block    
 224:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available          
 225:uCOSII/Source/os_mutex.c ****         if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 226:uCOSII/Source/os_mutex.c ****             OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry          
 227:uCOSII/Source/os_mutex.c ****         }
 228:uCOSII/Source/os_mutex.c ****         OS_EXIT_CRITICAL();
 229:uCOSII/Source/os_mutex.c ****        *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks         
 230:uCOSII/Source/os_mutex.c ****         return (pevent);
 231:uCOSII/Source/os_mutex.c ****     }
 232:uCOSII/Source/os_mutex.c ****     OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list         
 233:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 234:uCOSII/Source/os_mutex.c ****     pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
 235:uCOSII/Source/os_mutex.c ****     pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail. 
 236:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex             
 237:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 238:uCOSII/Source/os_mutex.c ****     pevent->OSEventName = (INT8U *)(void *)"?";
 239:uCOSII/Source/os_mutex.c **** #endif
 240:uCOSII/Source/os_mutex.c ****     OS_EventWaitListInit(pevent);
 241:uCOSII/Source/os_mutex.c ****    *perr = OS_ERR_NONE;
 242:uCOSII/Source/os_mutex.c ****     return (pevent);
 243:uCOSII/Source/os_mutex.c **** }
 244:uCOSII/Source/os_mutex.c **** 
 245:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 246:uCOSII/Source/os_mutex.c **** /*
 247:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 248:uCOSII/Source/os_mutex.c **** *                                           DELETE A MUTEX
 249:uCOSII/Source/os_mutex.c **** *
 250:uCOSII/Source/os_mutex.c **** * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on 
 251:uCOSII/Source/os_mutex.c **** *
 252:uCOSII/Source/os_mutex.c **** * Arguments  : pevent        is a pointer to the event control block associated with the desired mu
 253:uCOSII/Source/os_mutex.c **** *
 254:uCOSII/Source/os_mutex.c **** *              opt           determines delete options as follows:
 255:uCOSII/Source/os_mutex.c **** *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
 256:uCOSII/Source/os_mutex.c **** *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
 257:uCOSII/Source/os_mutex.c **** *                                                    In this case, all the tasks pending will be re
 258:uCOSII/Source/os_mutex.c **** *
ARM GAS  /tmp/ccyWPqe2.s 			page 6


 259:uCOSII/Source/os_mutex.c **** *              perr          is a pointer to an error code that can contain one of the following va
 260:uCOSII/Source/os_mutex.c **** *                            OS_ERR_NONE             The call was successful and the mutex was dele
 261:uCOSII/Source/os_mutex.c **** *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an I
 262:uCOSII/Source/os_mutex.c **** *                            OS_ERR_INVALID_OPT      An invalid option was specified
 263:uCOSII/Source/os_mutex.c **** *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
 264:uCOSII/Source/os_mutex.c **** *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
 265:uCOSII/Source/os_mutex.c **** *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
 266:uCOSII/Source/os_mutex.c **** *
 267:uCOSII/Source/os_mutex.c **** * Returns    : pevent        upon error
 268:uCOSII/Source/os_mutex.c **** *              (OS_EVENT *)0 if the mutex was successfully deleted.
 269:uCOSII/Source/os_mutex.c **** *
 270:uCOSII/Source/os_mutex.c **** * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the prese
 271:uCOSII/Source/os_mutex.c **** *                 the mutex MUST check the return code of OSMutexPend().
 272:uCOSII/Source/os_mutex.c **** *
 273:uCOSII/Source/os_mutex.c **** *              2) This call can potentially disable interrupts for a long time.  The interrupt disa
 274:uCOSII/Source/os_mutex.c **** *                 time is directly proportional to the number of tasks waiting on the mutex.
 275:uCOSII/Source/os_mutex.c **** *
 276:uCOSII/Source/os_mutex.c **** *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful becau
 277:uCOSII/Source/os_mutex.c **** *                 resource(s) will no longer be guarded by the mutex.
 278:uCOSII/Source/os_mutex.c **** *
 279:uCOSII/Source/os_mutex.c **** *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if
 280:uCOSII/Source/os_mutex.c **** *                            is one) is ready-to-run and is thus NOT pending on another kernel obje
 281:uCOSII/Source/os_mutex.c **** *                            has delayed itself.  In other words, if a task owns the mutex being de
 282:uCOSII/Source/os_mutex.c **** *                            that task will be made ready-to-run at its original priority.
 283:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 284:uCOSII/Source/os_mutex.c **** */
 285:uCOSII/Source/os_mutex.c **** 
 286:uCOSII/Source/os_mutex.c **** #if OS_MUTEX_DEL_EN > 0u
 287:uCOSII/Source/os_mutex.c **** OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
 288:uCOSII/Source/os_mutex.c ****                        INT8U      opt,
 289:uCOSII/Source/os_mutex.c ****                        INT8U     *perr)
 290:uCOSII/Source/os_mutex.c **** {
 291:uCOSII/Source/os_mutex.c ****     BOOLEAN    tasks_waiting;
 292:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent_return;
 293:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                        /* Priority ceiling priority            
 294:uCOSII/Source/os_mutex.c ****     INT8U      prio;
 295:uCOSII/Source/os_mutex.c ****     OS_TCB    *ptcb;
 296:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status regis
 297:uCOSII/Source/os_mutex.c ****     OS_CPU_SR  cpu_sr = 0u;
 298:uCOSII/Source/os_mutex.c **** #endif
 299:uCOSII/Source/os_mutex.c **** 
 300:uCOSII/Source/os_mutex.c **** 
 301:uCOSII/Source/os_mutex.c **** 
 302:uCOSII/Source/os_mutex.c **** #ifdef OS_SAFETY_CRITICAL
 303:uCOSII/Source/os_mutex.c ****     if (perr == (INT8U *)0) {
 304:uCOSII/Source/os_mutex.c ****         OS_SAFETY_CRITICAL_EXCEPTION();
 305:uCOSII/Source/os_mutex.c ****         return ((OS_EVENT *)0);
 306:uCOSII/Source/os_mutex.c ****     }
 307:uCOSII/Source/os_mutex.c **** #endif
 308:uCOSII/Source/os_mutex.c **** 
 309:uCOSII/Source/os_mutex.c **** #if OS_ARG_CHK_EN > 0u
 310:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                    
 311:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEVENT_NULL;
 312:uCOSII/Source/os_mutex.c ****         return (pevent);
 313:uCOSII/Source/os_mutex.c ****     }
 314:uCOSII/Source/os_mutex.c **** #endif
 315:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type            
ARM GAS  /tmp/ccyWPqe2.s 			page 7


 316:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 317:uCOSII/Source/os_mutex.c ****         return (pevent);
 318:uCOSII/Source/os_mutex.c ****     }
 319:uCOSII/Source/os_mutex.c ****     if (OSIntNesting > 0u) {                               /* See if called from ISR ...           
 320:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR        
 321:uCOSII/Source/os_mutex.c ****         return (pevent);
 322:uCOSII/Source/os_mutex.c ****     }
 323:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 324:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex    
 325:uCOSII/Source/os_mutex.c ****         tasks_waiting = OS_TRUE;                           /* Yes                                  
 326:uCOSII/Source/os_mutex.c ****     } else {
 327:uCOSII/Source/os_mutex.c ****         tasks_waiting = OS_FALSE;                          /* No                                   
 328:uCOSII/Source/os_mutex.c ****     }
 329:uCOSII/Source/os_mutex.c ****     switch (opt) {
 330:uCOSII/Source/os_mutex.c ****         case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING 
 331:uCOSII/Source/os_mutex.c ****              if (tasks_waiting == OS_FALSE) {
 332:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 333:uCOSII/Source/os_mutex.c ****                  pevent->OSEventName   = (INT8U *)(void *)"?";
 334:uCOSII/Source/os_mutex.c **** #endif
 335:uCOSII/Source/os_mutex.c ****                  pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
 336:uCOSII/Source/os_mutex.c ****                  if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 337:uCOSII/Source/os_mutex.c ****                      OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                      
 338:uCOSII/Source/os_mutex.c ****                  }
 339:uCOSII/Source/os_mutex.c ****                  pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
 340:uCOSII/Source/os_mutex.c ****                  pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free li
 341:uCOSII/Source/os_mutex.c ****                  pevent->OSEventCnt    = 0u;
 342:uCOSII/Source/os_mutex.c ****                  OSEventFreeList       = pevent;
 343:uCOSII/Source/os_mutex.c ****                  OS_EXIT_CRITICAL();
 344:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_NONE;
 345:uCOSII/Source/os_mutex.c ****                  pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted               
 346:uCOSII/Source/os_mutex.c ****              } else {
 347:uCOSII/Source/os_mutex.c ****                  OS_EXIT_CRITICAL();
 348:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_TASK_WAITING;
 349:uCOSII/Source/os_mutex.c ****                  pevent_return         = pevent;
 350:uCOSII/Source/os_mutex.c ****              }
 351:uCOSII/Source/os_mutex.c ****              break;
 352:uCOSII/Source/os_mutex.c **** 
 353:uCOSII/Source/os_mutex.c ****         case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX -------------
 354:uCOSII/Source/os_mutex.c ****              pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex   
 355:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 356:uCOSII/Source/os_mutex.c ****                  prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig pr
 357:uCOSII/Source/os_mutex.c ****                  ptcb = (OS_TCB *)pevent->OSEventPtr;
 358:uCOSII/Source/os_mutex.c ****                  if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex       
 359:uCOSII/Source/os_mutex.c ****                      if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed     
 360:uCOSII/Source/os_mutex.c ****                          OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio
 361:uCOSII/Source/os_mutex.c ****                      }
 362:uCOSII/Source/os_mutex.c ****                  }
 363:uCOSII/Source/os_mutex.c ****              }
 364:uCOSII/Source/os_mutex.c ****              while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex    
 365:uCOSII/Source/os_mutex.c ****                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
 366:uCOSII/Source/os_mutex.c ****              }
 367:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 368:uCOSII/Source/os_mutex.c ****              pevent->OSEventName   = (INT8U *)(void *)"?";
 369:uCOSII/Source/os_mutex.c **** #endif
 370:uCOSII/Source/os_mutex.c ****              pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
 371:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 372:uCOSII/Source/os_mutex.c ****                  OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                      
ARM GAS  /tmp/ccyWPqe2.s 			page 8


 373:uCOSII/Source/os_mutex.c ****              }
 374:uCOSII/Source/os_mutex.c ****              pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
 375:uCOSII/Source/os_mutex.c ****              pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free li
 376:uCOSII/Source/os_mutex.c ****              pevent->OSEventCnt    = 0u;
 377:uCOSII/Source/os_mutex.c ****              OSEventFreeList       = pevent;               /* Get next free event control block    
 378:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();
 379:uCOSII/Source/os_mutex.c ****              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiti
 380:uCOSII/Source/os_mutex.c ****                  OS_Sched();                               /* Find highest priority task ready to r
 381:uCOSII/Source/os_mutex.c ****              }
 382:uCOSII/Source/os_mutex.c ****              *perr         = OS_ERR_NONE;
 383:uCOSII/Source/os_mutex.c ****              pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted               
 384:uCOSII/Source/os_mutex.c ****              break;
 385:uCOSII/Source/os_mutex.c **** 
 386:uCOSII/Source/os_mutex.c ****         default:
 387:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();
 388:uCOSII/Source/os_mutex.c ****              *perr         = OS_ERR_INVALID_OPT;
 389:uCOSII/Source/os_mutex.c ****              pevent_return = pevent;
 390:uCOSII/Source/os_mutex.c ****              break;
 391:uCOSII/Source/os_mutex.c ****     }
 392:uCOSII/Source/os_mutex.c ****     return (pevent_return);
 393:uCOSII/Source/os_mutex.c **** }
 394:uCOSII/Source/os_mutex.c **** #endif
 395:uCOSII/Source/os_mutex.c **** 
 396:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 397:uCOSII/Source/os_mutex.c **** /*
 398:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 399:uCOSII/Source/os_mutex.c **** *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
 400:uCOSII/Source/os_mutex.c **** *
 401:uCOSII/Source/os_mutex.c **** * Description: This function waits for a mutual exclusion semaphore.
 402:uCOSII/Source/os_mutex.c **** *
 403:uCOSII/Source/os_mutex.c **** * Arguments  : pevent        is a pointer to the event control block associated with the desired
 404:uCOSII/Source/os_mutex.c **** *                            mutex.
 405:uCOSII/Source/os_mutex.c **** *
 406:uCOSII/Source/os_mutex.c **** *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your tas
 407:uCOSII/Source/os_mutex.c **** *                            wait for the resource up to the amount of time specified by this argum
 408:uCOSII/Source/os_mutex.c **** *                            If you specify 0, however, your task will wait forever at the specifie
 409:uCOSII/Source/os_mutex.c **** *                            mutex or, until the resource becomes available.
 410:uCOSII/Source/os_mutex.c **** *
 411:uCOSII/Source/os_mutex.c **** *              perr          is a pointer to where an error message will be deposited.  Possible er
 412:uCOSII/Source/os_mutex.c **** *                            messages are:
 413:uCOSII/Source/os_mutex.c **** *                               OS_ERR_NONE        The call was successful and your task owns the m
 414:uCOSII/Source/os_mutex.c **** *                               OS_ERR_TIMEOUT     The mutex was not available within the specified
 415:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
 416:uCOSII/Source/os_mutex.c **** *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
 417:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
 418:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the 
 419:uCOSII/Source/os_mutex.c **** *                                                  would lead to a suspension.
 420:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex 
 421:uCOSII/Source/os_mutex.c **** *                                                  HIGHER (i.e. a lower number) than the PCP.  This
 422:uCOSII/Source/os_mutex.c **** *                                                  indicates that you did not set the PCP higher (l
 423:uCOSII/Source/os_mutex.c **** *                                                  number) than ALL the tasks that compete for the 
 424:uCOSII/Source/os_mutex.c **** *                                                  Unfortunately, this is something that could not 
 425:uCOSII/Source/os_mutex.c **** *                                                  detected when the Mutex is created because we do
 426:uCOSII/Source/os_mutex.c **** *                                                  what tasks will be using the Mutex.
 427:uCOSII/Source/os_mutex.c **** *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler i
 428:uCOSII/Source/os_mutex.c **** *
 429:uCOSII/Source/os_mutex.c **** * Returns    : none
ARM GAS  /tmp/ccyWPqe2.s 			page 9


 430:uCOSII/Source/os_mutex.c **** *
 431:uCOSII/Source/os_mutex.c **** * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the m
 432:uCOSII/Source/os_mutex.c **** *
 433:uCOSII/Source/os_mutex.c **** *              2) You MUST NOT change the priority of the task that owns the mutex
 434:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 435:uCOSII/Source/os_mutex.c **** */
 436:uCOSII/Source/os_mutex.c **** 
 437:uCOSII/Source/os_mutex.c **** void  OSMutexPend (OS_EVENT  *pevent,
 438:uCOSII/Source/os_mutex.c ****                    INT32U     timeout,
 439:uCOSII/Source/os_mutex.c ****                    INT8U     *perr)
 440:uCOSII/Source/os_mutex.c **** {
 441:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)      
 442:uCOSII/Source/os_mutex.c ****     INT8U      mprio;                                      /* Mutex owner priority                 
 443:uCOSII/Source/os_mutex.c ****     BOOLEAN    rdy;                                        /* Flag indicating task was ready       
 444:uCOSII/Source/os_mutex.c ****     OS_TCB    *ptcb;
 445:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent2;
 446:uCOSII/Source/os_mutex.c ****     INT8U      y;
 447:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status regis
 448:uCOSII/Source/os_mutex.c ****     OS_CPU_SR  cpu_sr = 0u;
 449:uCOSII/Source/os_mutex.c **** #endif
 450:uCOSII/Source/os_mutex.c **** 
 451:uCOSII/Source/os_mutex.c **** 
 452:uCOSII/Source/os_mutex.c **** 
 453:uCOSII/Source/os_mutex.c **** #ifdef OS_SAFETY_CRITICAL
 454:uCOSII/Source/os_mutex.c ****     if (perr == (INT8U *)0) {
 455:uCOSII/Source/os_mutex.c ****         OS_SAFETY_CRITICAL_EXCEPTION();
 456:uCOSII/Source/os_mutex.c ****         return;
 457:uCOSII/Source/os_mutex.c ****     }
 458:uCOSII/Source/os_mutex.c **** #endif
 459:uCOSII/Source/os_mutex.c **** 
 460:uCOSII/Source/os_mutex.c **** #if OS_ARG_CHK_EN > 0u
 461:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                    
 462:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEVENT_NULL;
 463:uCOSII/Source/os_mutex.c ****         return;
 464:uCOSII/Source/os_mutex.c ****     }
 465:uCOSII/Source/os_mutex.c **** #endif
 466:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type            
 467:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 468:uCOSII/Source/os_mutex.c ****         return;
 469:uCOSII/Source/os_mutex.c ****     }
 470:uCOSII/Source/os_mutex.c ****     if (OSIntNesting > 0u) {                               /* See if called from ISR ...           
 471:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR           
 472:uCOSII/Source/os_mutex.c ****         return;
 473:uCOSII/Source/os_mutex.c ****     }
 474:uCOSII/Source/os_mutex.c ****     if (OSLockNesting > 0u) {                              /* See if called with scheduler locked .
 475:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked           
 476:uCOSII/Source/os_mutex.c ****         return;
 477:uCOSII/Source/os_mutex.c ****     }
 478:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 479:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 480:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                   
 481:uCOSII/Source/os_mutex.c ****                                                            /* Is Mutex available?                  
 482:uCOSII/Source/os_mutex.c ****     if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 483:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource            
 484:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task    
 485:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB   
 486:uCOSII/Source/os_mutex.c ****         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
ARM GAS  /tmp/ccyWPqe2.s 			page 10


 487:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio .
 488:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();                           /*      ... than current task!          
 489:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_PCP_LOWER;
 490:uCOSII/Source/os_mutex.c ****         } else {
 491:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();
 492:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_NONE;
 493:uCOSII/Source/os_mutex.c ****         }
 494:uCOSII/Source/os_mutex.c ****         return;
 495:uCOSII/Source/os_mutex.c ****     }
 496:uCOSII/Source/os_mutex.c ****     if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 497:uCOSII/Source/os_mutex.c ****         mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owne
 498:uCOSII/Source/os_mutex.c ****         ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owne
 499:uCOSII/Source/os_mutex.c ****         if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of ow
 500:uCOSII/Source/os_mutex.c ****             if (mprio > OSTCBCur->OSTCBPrio) {
 501:uCOSII/Source/os_mutex.c ****                 y = ptcb->OSTCBY;
 502:uCOSII/Source/os_mutex.c ****                 if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is read
 503:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy
 504:uCOSII/Source/os_mutex.c ****                     if (OSRdyTbl[y] == 0u) {                      /*          ... list at current p
 505:uCOSII/Source/os_mutex.c ****                         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 506:uCOSII/Source/os_mutex.c ****                     }
 507:uCOSII/Source/os_mutex.c ****                     rdy = OS_TRUE;
 508:uCOSII/Source/os_mutex.c ****                 } else {
 509:uCOSII/Source/os_mutex.c ****                     pevent2 = ptcb->OSTCBEventPtr;
 510:uCOSII/Source/os_mutex.c ****                     if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list   
 511:uCOSII/Source/os_mutex.c ****                         y = ptcb->OSTCBY;
 512:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
 513:uCOSII/Source/os_mutex.c ****                         if (pevent2->OSEventTbl[y] == 0u) {
 514:uCOSII/Source/os_mutex.c ****                             pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 515:uCOSII/Source/os_mutex.c ****                         }
 516:uCOSII/Source/os_mutex.c ****                     }
 517:uCOSII/Source/os_mutex.c ****                     rdy = OS_FALSE;                        /* No                                   
 518:uCOSII/Source/os_mutex.c ****                 }
 519:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP        
 520:uCOSII/Source/os_mutex.c **** #if OS_LOWEST_PRIO <= 63u
 521:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
 522:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
 523:uCOSII/Source/os_mutex.c **** #else
 524:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
 525:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
 526:uCOSII/Source/os_mutex.c **** #endif
 527:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
 528:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
 529:uCOSII/Source/os_mutex.c **** 
 530:uCOSII/Source/os_mutex.c ****                 if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority
 531:uCOSII/Source/os_mutex.c ****                     OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority
 532:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 533:uCOSII/Source/os_mutex.c ****                 } else {
 534:uCOSII/Source/os_mutex.c ****                     pevent2 = ptcb->OSTCBEventPtr;
 535:uCOSII/Source/os_mutex.c ****                     if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list               
 536:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
 537:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 538:uCOSII/Source/os_mutex.c ****                     }
 539:uCOSII/Source/os_mutex.c ****                 }
 540:uCOSII/Source/os_mutex.c ****                 OSTCBPrioTbl[pcp] = ptcb;
 541:uCOSII/Source/os_mutex.c ****             }
 542:uCOSII/Source/os_mutex.c ****         }
 543:uCOSII/Source/os_mutex.c ****     }
ARM GAS  /tmp/ccyWPqe2.s 			page 11


 544:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task    
 545:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 546:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB       
 547:uCOSII/Source/os_mutex.c ****     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs
 548:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 549:uCOSII/Source/os_mutex.c ****     OS_Sched();                                       /* Find next highest priority task ready     
 550:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 551:uCOSII/Source/os_mutex.c ****     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted            
 552:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_OK:
 553:uCOSII/Source/os_mutex.c ****              *perr = OS_ERR_NONE;
 554:uCOSII/Source/os_mutex.c ****              break;
 555:uCOSII/Source/os_mutex.c **** 
 556:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_ABORT:
 557:uCOSII/Source/os_mutex.c ****              *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex    
 558:uCOSII/Source/os_mutex.c ****              break;
 559:uCOSII/Source/os_mutex.c **** 
 560:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_TO:
 561:uCOSII/Source/os_mutex.c ****         default:
 562:uCOSII/Source/os_mutex.c ****              OS_EventTaskRemove(OSTCBCur, pevent);
 563:uCOSII/Source/os_mutex.c ****              *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within T
 564:uCOSII/Source/os_mutex.c ****              break;
 565:uCOSII/Source/os_mutex.c ****     }
 566:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready               
 567:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                        
 568:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                      
 569:uCOSII/Source/os_mutex.c **** #if (OS_EVENT_MULTI_EN > 0u)
 570:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 571:uCOSII/Source/os_mutex.c **** #endif
 572:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 573:uCOSII/Source/os_mutex.c **** }
 574:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 575:uCOSII/Source/os_mutex.c **** /*
 576:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 577:uCOSII/Source/os_mutex.c **** *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
 578:uCOSII/Source/os_mutex.c **** *
 579:uCOSII/Source/os_mutex.c **** * Description: This function signals a mutual exclusion semaphore
 580:uCOSII/Source/os_mutex.c **** *
 581:uCOSII/Source/os_mutex.c **** * Arguments  : pevent              is a pointer to the event control block associated with the desi
 582:uCOSII/Source/os_mutex.c **** *                                  mutex.
 583:uCOSII/Source/os_mutex.c **** *
 584:uCOSII/Source/os_mutex.c **** * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
 585:uCOSII/Source/os_mutex.c **** *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
 586:uCOSII/Source/os_mutex.c **** *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
 587:uCOSII/Source/os_mutex.c **** *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
 588:uCOSII/Source/os_mutex.c **** *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
 589:uCOSII/Source/os_mutex.c **** *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
 590:uCOSII/Source/os_mutex.c **** *                                      HIGHER (i.e. a lower number) than the PCP.  This error
 591:uCOSII/Source/os_mutex.c **** *                                      indicates that you did not set the PCP higher (lower
 592:uCOSII/Source/os_mutex.c **** *                                      number) than ALL the tasks that compete for the Mutex.
 593:uCOSII/Source/os_mutex.c **** *                                      Unfortunately, this is something that could not be
 594:uCOSII/Source/os_mutex.c **** *                                      detected when the Mutex is created because we don't know
 595:uCOSII/Source/os_mutex.c **** *                                      what tasks will be using the Mutex.
 596:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 597:uCOSII/Source/os_mutex.c **** */
 598:uCOSII/Source/os_mutex.c **** 
 599:uCOSII/Source/os_mutex.c **** INT8U  OSMutexPost (OS_EVENT *pevent)
 600:uCOSII/Source/os_mutex.c **** {
ARM GAS  /tmp/ccyWPqe2.s 			page 12


 601:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                   /* Priority ceiling priority                 
 602:uCOSII/Source/os_mutex.c ****     INT8U      prio;
 603:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register  
 604:uCOSII/Source/os_mutex.c ****     OS_CPU_SR  cpu_sr = 0u;
 605:uCOSII/Source/os_mutex.c **** #endif
 606:uCOSII/Source/os_mutex.c **** 
 607:uCOSII/Source/os_mutex.c **** 
 608:uCOSII/Source/os_mutex.c **** 
 609:uCOSII/Source/os_mutex.c ****     if (OSIntNesting > 0u) {                          /* See if called from ISR ...                
 610:uCOSII/Source/os_mutex.c ****         return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR          
 611:uCOSII/Source/os_mutex.c ****     }
 612:uCOSII/Source/os_mutex.c **** #if OS_ARG_CHK_EN > 0u
 613:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                         
 614:uCOSII/Source/os_mutex.c ****         return (OS_ERR_PEVENT_NULL);
 615:uCOSII/Source/os_mutex.c ****     }
 616:uCOSII/Source/os_mutex.c **** #endif
 617:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                 
 618:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 619:uCOSII/Source/os_mutex.c ****     }
 620:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 621:uCOSII/Source/os_mutex.c ****     pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex    
 622:uCOSII/Source/os_mutex.c ****     prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority  
 623:uCOSII/Source/os_mutex.c ****     if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX        
 624:uCOSII/Source/os_mutex.c ****         OS_EXIT_CRITICAL();
 625:uCOSII/Source/os_mutex.c ****         return (OS_ERR_NOT_MUTEX_OWNER);
 626:uCOSII/Source/os_mutex.c ****     }
 627:uCOSII/Source/os_mutex.c ****     if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 628:uCOSII/Source/os_mutex.c ****         if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priori
 629:uCOSII/Source/os_mutex.c ****             OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority      
 630:uCOSII/Source/os_mutex.c ****         }
 631:uCOSII/Source/os_mutex.c ****         OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                       
 632:uCOSII/Source/os_mutex.c ****     }
 633:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?           
 634:uCOSII/Source/os_mutex.c ****                                                       /* Yes, Make HPT waiting for mutex ready     
 635:uCOSII/Source/os_mutex.c ****         prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
 636:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner   
 637:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= prio;
 638:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB     
 639:uCOSII/Source/os_mutex.c ****         if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
 640:uCOSII/Source/os_mutex.c ****             (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...   
 641:uCOSII/Source/os_mutex.c ****             OS_EXIT_CRITICAL();                       /*      ... than current task!               
 642:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 643:uCOSII/Source/os_mutex.c ****             return (OS_ERR_PCP_LOWER);
 644:uCOSII/Source/os_mutex.c ****         } else {
 645:uCOSII/Source/os_mutex.c ****             OS_EXIT_CRITICAL();
 646:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 647:uCOSII/Source/os_mutex.c ****             return (OS_ERR_NONE);
 648:uCOSII/Source/os_mutex.c ****         }
 649:uCOSII/Source/os_mutex.c ****     }
 650:uCOSII/Source/os_mutex.c ****     pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available               
 651:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;
 652:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 653:uCOSII/Source/os_mutex.c ****     return (OS_ERR_NONE);
 654:uCOSII/Source/os_mutex.c **** }
 655:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 656:uCOSII/Source/os_mutex.c **** /*
 657:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
ARM GAS  /tmp/ccyWPqe2.s 			page 13


 658:uCOSII/Source/os_mutex.c **** *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
 659:uCOSII/Source/os_mutex.c **** *
 660:uCOSII/Source/os_mutex.c **** * Description: This function obtains information about a mutex
 661:uCOSII/Source/os_mutex.c **** *
 662:uCOSII/Source/os_mutex.c **** * Arguments  : pevent          is a pointer to the event control block associated with the desired 
 663:uCOSII/Source/os_mutex.c **** *
 664:uCOSII/Source/os_mutex.c **** *              p_mutex_data    is a pointer to a structure that will contain information about the 
 665:uCOSII/Source/os_mutex.c **** *
 666:uCOSII/Source/os_mutex.c **** * Returns    : OS_ERR_NONE          The call was successful and the message was sent
 667:uCOSII/Source/os_mutex.c **** *              OS_ERR_QUERY_ISR     If you called this function from an ISR
 668:uCOSII/Source/os_mutex.c **** *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
 669:uCOSII/Source/os_mutex.c **** *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
 670:uCOSII/Source/os_mutex.c **** *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
 671:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 672:uCOSII/Source/os_mutex.c **** */
 673:uCOSII/Source/os_mutex.c **** 
 674:uCOSII/Source/os_mutex.c **** #if OS_MUTEX_QUERY_EN > 0u
 675:uCOSII/Source/os_mutex.c **** INT8U  OSMutexQuery (OS_EVENT       *pevent,
 676:uCOSII/Source/os_mutex.c ****                      OS_MUTEX_DATA  *p_mutex_data)
 677:uCOSII/Source/os_mutex.c **** {
 678:uCOSII/Source/os_mutex.c ****     INT8U       i;
 679:uCOSII/Source/os_mutex.c ****     OS_PRIO    *psrc;
 680:uCOSII/Source/os_mutex.c ****     OS_PRIO    *pdest;
 681:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register       
 682:uCOSII/Source/os_mutex.c ****     OS_CPU_SR   cpu_sr = 0u;
 683:uCOSII/Source/os_mutex.c **** #endif
 684:uCOSII/Source/os_mutex.c **** 
 685:uCOSII/Source/os_mutex.c **** 
 686:uCOSII/Source/os_mutex.c **** 
 687:uCOSII/Source/os_mutex.c ****     if (OSIntNesting > 0u) {                               /* See if called from ISR ...           
 688:uCOSII/Source/os_mutex.c ****         return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR    
 689:uCOSII/Source/os_mutex.c ****     }
 690:uCOSII/Source/os_mutex.c **** #if OS_ARG_CHK_EN > 0u
 691:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                    
 692:uCOSII/Source/os_mutex.c ****         return (OS_ERR_PEVENT_NULL);
 693:uCOSII/Source/os_mutex.c ****     }
 694:uCOSII/Source/os_mutex.c ****     if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'              
 695:uCOSII/Source/os_mutex.c ****         return (OS_ERR_PDATA_NULL);
 696:uCOSII/Source/os_mutex.c ****     }
 697:uCOSII/Source/os_mutex.c **** #endif
 698:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type            
 699:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 700:uCOSII/Source/os_mutex.c ****     }
 701:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 702:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
 703:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 704:uCOSII/Source/os_mutex.c ****     if (p_mutex_data->OSOwnerPrio == 0xFFu) {
 705:uCOSII/Source/os_mutex.c ****         p_mutex_data->OSValue = OS_TRUE;
 706:uCOSII/Source/os_mutex.c ****     } else {
 707:uCOSII/Source/os_mutex.c ****         p_mutex_data->OSValue = OS_FALSE;
 708:uCOSII/Source/os_mutex.c ****     }
 709:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                       
 710:uCOSII/Source/os_mutex.c ****     psrc                      = &pevent->OSEventTbl[0];
 711:uCOSII/Source/os_mutex.c ****     pdest                     = &p_mutex_data->OSEventTbl[0];
 712:uCOSII/Source/os_mutex.c ****     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
 713:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 714:uCOSII/Source/os_mutex.c ****     }
ARM GAS  /tmp/ccyWPqe2.s 			page 14


 715:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 716:uCOSII/Source/os_mutex.c ****     return (OS_ERR_NONE);
 717:uCOSII/Source/os_mutex.c **** }
 718:uCOSII/Source/os_mutex.c **** #endif                                                     /* OS_MUTEX_QUERY_EN                    
 719:uCOSII/Source/os_mutex.c **** 
 720:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 721:uCOSII/Source/os_mutex.c **** /*
 722:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 723:uCOSII/Source/os_mutex.c **** *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
 724:uCOSII/Source/os_mutex.c **** *
 725:uCOSII/Source/os_mutex.c **** * Description: This function makes a task ready at the specified priority
 726:uCOSII/Source/os_mutex.c **** *
 727:uCOSII/Source/os_mutex.c **** * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
 728:uCOSII/Source/os_mutex.c **** *
 729:uCOSII/Source/os_mutex.c **** *              prio            is the desired priority
 730:uCOSII/Source/os_mutex.c **** *
 731:uCOSII/Source/os_mutex.c **** * Returns    : none
 732:uCOSII/Source/os_mutex.c **** ***************************************************************************************************
 733:uCOSII/Source/os_mutex.c **** */
 734:uCOSII/Source/os_mutex.c **** 
 735:uCOSII/Source/os_mutex.c **** static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
 736:uCOSII/Source/os_mutex.c ****                                  INT8U    prio)
 737:uCOSII/Source/os_mutex.c **** {
  29              		.loc 1 737 1 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              		.loc 1 737 1 is_stmt 0 view .LVU1
  35 0000 70B4     		push	{r4, r5, r6}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 12
  38              		.cfi_offset 4, -12
  39              		.cfi_offset 5, -8
  40              		.cfi_offset 6, -4
 738:uCOSII/Source/os_mutex.c ****     INT8U  y;
  41              		.loc 1 738 5 is_stmt 1 view .LVU2
 739:uCOSII/Source/os_mutex.c **** 
 740:uCOSII/Source/os_mutex.c **** 
 741:uCOSII/Source/os_mutex.c ****     y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'
  42              		.loc 1 741 5 view .LVU3
  43              		.loc 1 741 18 is_stmt 0 view .LVU4
  44 0002 90F83820 		ldrb	r2, [r0, #56]	@ zero_extendqisi2
  45              	.LVL1:
 742:uCOSII/Source/os_mutex.c ****     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
  46              		.loc 1 742 5 is_stmt 1 view .LVU5
  47              		.loc 1 742 34 is_stmt 0 view .LVU6
  48 0006 90F83950 		ldrb	r5, [r0, #57]	@ zero_extendqisi2
  49              		.loc 1 742 17 view .LVU7
  50 000a 184C     		ldr	r4, .L4
  51 000c A35C     		ldrb	r3, [r4, r2]	@ zero_extendqisi2
  52 000e 23EA0503 		bic	r3, r3, r5
  53 0012 A354     		strb	r3, [r4, r2]
 743:uCOSII/Source/os_mutex.c ****     if (OSRdyTbl[y] == 0u) {
  54              		.loc 1 743 5 is_stmt 1 view .LVU8
  55              		.loc 1 743 8 is_stmt 0 view .LVU9
  56 0014 33B9     		cbnz	r3, .L2
ARM GAS  /tmp/ccyWPqe2.s 			page 15


 744:uCOSII/Source/os_mutex.c ****         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
  57              		.loc 1 744 9 is_stmt 1 view .LVU10
  58              		.loc 1 744 35 is_stmt 0 view .LVU11
  59 0016 90F83A40 		ldrb	r4, [r0, #58]	@ zero_extendqisi2
  60              		.loc 1 744 18 view .LVU12
  61 001a 154A     		ldr	r2, .L4+4
  62              	.LVL2:
  63              		.loc 1 744 18 view .LVU13
  64 001c 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
  65 001e 23EA0403 		bic	r3, r3, r4
  66 0022 1370     		strb	r3, [r2]
  67              	.L2:
 745:uCOSII/Source/os_mutex.c ****     }
 746:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBPrio         = prio;
  68              		.loc 1 746 5 is_stmt 1 view .LVU14
  69              		.loc 1 746 29 is_stmt 0 view .LVU15
  70 0024 80F83610 		strb	r1, [r0, #54]
 747:uCOSII/Source/os_mutex.c ****     OSPrioCur               = prio;                        /* The current task is now at this prior
  71              		.loc 1 747 5 is_stmt 1 view .LVU16
  72              		.loc 1 747 29 is_stmt 0 view .LVU17
  73 0028 124B     		ldr	r3, .L4+8
  74 002a 1970     		strb	r1, [r3]
 748:uCOSII/Source/os_mutex.c **** #if OS_LOWEST_PRIO <= 63u
 749:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
  75              		.loc 1 749 5 is_stmt 1 view .LVU18
  76              		.loc 1 749 31 is_stmt 0 view .LVU19
  77 002c C1F3C204 		ubfx	r4, r1, #3, #3
  78              		.loc 1 749 29 view .LVU20
  79 0030 80F83840 		strb	r4, [r0, #56]
  80              	.LVL3:
 750:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
  81              		.loc 1 750 5 is_stmt 1 view .LVU21
  82              		.loc 1 750 31 is_stmt 0 view .LVU22
  83 0034 01F00705 		and	r5, r1, #7
  84              		.loc 1 750 29 view .LVU23
  85 0038 80F83750 		strb	r5, [r0, #55]
 751:uCOSII/Source/os_mutex.c **** #else
 752:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
 753:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
 754:uCOSII/Source/os_mutex.c **** #endif
 755:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
  86              		.loc 1 755 5 is_stmt 1 view .LVU24
  87              		.loc 1 755 45 is_stmt 0 view .LVU25
  88 003c 0123     		movs	r3, #1
  89 003e 03FA04F2 		lsl	r2, r3, r4
  90              		.loc 1 755 31 view .LVU26
  91 0042 D2B2     		uxtb	r2, r2
  92              		.loc 1 755 29 view .LVU27
  93 0044 80F83A20 		strb	r2, [r0, #58]
 756:uCOSII/Source/os_mutex.c ****     ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
  94              		.loc 1 756 5 is_stmt 1 view .LVU28
  95              		.loc 1 756 45 is_stmt 0 view .LVU29
  96 0048 AB40     		lsls	r3, r3, r5
  97              		.loc 1 756 31 view .LVU30
  98 004a DBB2     		uxtb	r3, r3
  99              		.loc 1 756 29 view .LVU31
 100 004c 80F83930 		strb	r3, [r0, #57]
ARM GAS  /tmp/ccyWPqe2.s 			page 16


 757:uCOSII/Source/os_mutex.c ****     OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority 
 101              		.loc 1 757 5 is_stmt 1 view .LVU32
 102              		.loc 1 757 28 is_stmt 0 view .LVU33
 103 0050 074D     		ldr	r5, .L4+4
 104 0052 2E78     		ldrb	r6, [r5]	@ zero_extendqisi2
 105 0054 3243     		orrs	r2, r2, r6
 106 0056 2A70     		strb	r2, [r5]
 758:uCOSII/Source/os_mutex.c ****     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 107              		.loc 1 758 5 is_stmt 1 view .LVU34
 108              		.loc 1 758 28 is_stmt 0 view .LVU35
 109 0058 044A     		ldr	r2, .L4
 110 005a 155D     		ldrb	r5, [r2, r4]	@ zero_extendqisi2
 111 005c 2B43     		orrs	r3, r3, r5
 112 005e 1355     		strb	r3, [r2, r4]
 759:uCOSII/Source/os_mutex.c ****     OSTCBPrioTbl[prio]      = ptcb;
 113              		.loc 1 759 5 is_stmt 1 view .LVU36
 114              		.loc 1 759 29 is_stmt 0 view .LVU37
 115 0060 054B     		ldr	r3, .L4+12
 116 0062 43F82100 		str	r0, [r3, r1, lsl #2]
 760:uCOSII/Source/os_mutex.c **** }
 117              		.loc 1 760 1 view .LVU38
 118 0066 70BC     		pop	{r4, r5, r6}
 119              	.LCFI1:
 120              		.cfi_restore 6
 121              		.cfi_restore 5
 122              		.cfi_restore 4
 123              		.cfi_def_cfa_offset 0
 124 0068 7047     		bx	lr
 125              	.L5:
 126 006a 00BF     		.align	2
 127              	.L4:
 128 006c 00000000 		.word	OSRdyTbl
 129 0070 00000000 		.word	OSRdyGrp
 130 0074 00000000 		.word	OSPrioCur
 131 0078 00000000 		.word	OSTCBPrioTbl
 132              		.cfi_endproc
 133              	.LFE6:
 135              		.section	.text.OSMutexAccept,"ax",%progbits
 136              		.align	1
 137              		.global	OSMutexAccept
 138              		.syntax unified
 139              		.thumb
 140              		.thumb_func
 141              		.fpu fpv4-sp-d16
 143              	OSMutexAccept:
 144              	.LVL4:
 145              	.LFB0:
  88:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)          
 146              		.loc 1 88 1 is_stmt 1 view -0
 147              		.cfi_startproc
 148              		@ args = 0, pretend = 0, frame = 0
 149              		@ frame_needed = 0, uses_anonymous_args = 0
  88:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)          
 150              		.loc 1 88 1 is_stmt 0 view .LVU40
 151 0000 70B5     		push	{r4, r5, r6, lr}
 152              	.LCFI2:
 153              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccyWPqe2.s 			page 17


 154              		.cfi_offset 4, -16
 155              		.cfi_offset 5, -12
 156              		.cfi_offset 6, -8
 157              		.cfi_offset 14, -4
 158 0002 0E46     		mov	r6, r1
  89:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register 
 159              		.loc 1 89 5 is_stmt 1 view .LVU41
  91:uCOSII/Source/os_mutex.c **** #endif
 160              		.loc 1 91 5 view .LVU42
 161              	.LVL5:
 109:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 162              		.loc 1 109 5 view .LVU43
 109:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 163              		.loc 1 109 15 is_stmt 0 view .LVU44
 164 0004 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 109:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 165              		.loc 1 109 8 view .LVU45
 166 0006 042B     		cmp	r3, #4
 167 0008 04D0     		beq	.L7
 110:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 168              		.loc 1 110 9 is_stmt 1 view .LVU46
 110:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 169              		.loc 1 110 15 is_stmt 0 view .LVU47
 170 000a 0123     		movs	r3, #1
 171 000c 0B70     		strb	r3, [r1]
 111:uCOSII/Source/os_mutex.c ****     }
 172              		.loc 1 111 9 is_stmt 1 view .LVU48
 111:uCOSII/Source/os_mutex.c ****     }
 173              		.loc 1 111 16 is_stmt 0 view .LVU49
 174 000e 0025     		movs	r5, #0
 175              	.LVL6:
 176              	.L8:
 136:uCOSII/Source/os_mutex.c **** #endif
 177              		.loc 1 136 1 view .LVU50
 178 0010 2846     		mov	r0, r5
 179 0012 70BD     		pop	{r4, r5, r6, pc}
 180              	.LVL7:
 181              	.L7:
 136:uCOSII/Source/os_mutex.c **** #endif
 182              		.loc 1 136 1 view .LVU51
 183 0014 0446     		mov	r4, r0
 113:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;
 184              		.loc 1 113 5 is_stmt 1 view .LVU52
 113:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;
 185              		.loc 1 113 22 is_stmt 0 view .LVU53
 186 0016 174B     		ldr	r3, .L16
 187 0018 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 113:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;
 188              		.loc 1 113 8 view .LVU54
 189 001a 1DB1     		cbz	r5, .L9
 114:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 190              		.loc 1 114 9 is_stmt 1 view .LVU55
 114:uCOSII/Source/os_mutex.c ****         return (OS_FALSE);
 191              		.loc 1 114 15 is_stmt 0 view .LVU56
 192 001c 0223     		movs	r3, #2
 193 001e 0B70     		strb	r3, [r1]
 115:uCOSII/Source/os_mutex.c ****     }
ARM GAS  /tmp/ccyWPqe2.s 			page 18


 194              		.loc 1 115 9 is_stmt 1 view .LVU57
 115:uCOSII/Source/os_mutex.c ****     }
 195              		.loc 1 115 16 is_stmt 0 view .LVU58
 196 0020 0025     		movs	r5, #0
 197 0022 F5E7     		b	.L8
 198              	.L9:
 117:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                       
 199              		.loc 1 117 5 is_stmt 1 view .LVU59
 200 0024 FFF7FEFF 		bl	OS_CPU_SR_Save
 201              	.LVL8:
 117:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                       
 202              		.loc 1 117 24 view .LVU60
 118:uCOSII/Source/os_mutex.c ****     if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 203              		.loc 1 118 5 view .LVU61
 118:uCOSII/Source/os_mutex.c ****     if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 204              		.loc 1 118 25 is_stmt 0 view .LVU62
 205 0028 2389     		ldrh	r3, [r4, #8]
 118:uCOSII/Source/os_mutex.c ****     if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 206              		.loc 1 118 9 view .LVU63
 207 002a 190A     		lsrs	r1, r3, #8
 208              	.LVL9:
 119:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)     
 209              		.loc 1 119 5 is_stmt 1 view .LVU64
 119:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)     
 210              		.loc 1 119 8 is_stmt 0 view .LVU65
 211 002c DAB2     		uxtb	r2, r3
 212 002e FF2A     		cmp	r2, #255
 213 0030 04D0     		beq	.L14
 133:uCOSII/Source/os_mutex.c ****     *perr = OS_ERR_NONE;
 214              		.loc 1 133 5 is_stmt 1 view .LVU66
 215 0032 FFF7FEFF 		bl	OS_CPU_SR_Restore
 216              	.LVL10:
 133:uCOSII/Source/os_mutex.c ****     *perr = OS_ERR_NONE;
 217              		.loc 1 133 23 view .LVU67
 134:uCOSII/Source/os_mutex.c ****     return (OS_FALSE);
 218              		.loc 1 134 5 view .LVU68
 134:uCOSII/Source/os_mutex.c ****     return (OS_FALSE);
 219              		.loc 1 134 11 is_stmt 0 view .LVU69
 220 0036 0023     		movs	r3, #0
 221 0038 3370     		strb	r3, [r6]
 135:uCOSII/Source/os_mutex.c **** }
 222              		.loc 1 135 5 is_stmt 1 view .LVU70
 135:uCOSII/Source/os_mutex.c **** }
 223              		.loc 1 135 12 is_stmt 0 view .LVU71
 224 003a E9E7     		b	.L8
 225              	.LVL11:
 226              	.L14:
 120:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte
 227              		.loc 1 120 9 is_stmt 1 view .LVU72
 120:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte
 228              		.loc 1 120 28 is_stmt 0 view .LVU73
 229 003c 03F47F43 		and	r3, r3, #65280
 230 0040 2381     		strh	r3, [r4, #8]	@ movhi
 121:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex       
 231              		.loc 1 121 9 is_stmt 1 view .LVU74
 121:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex       
 232              		.loc 1 121 39 is_stmt 0 view .LVU75
ARM GAS  /tmp/ccyWPqe2.s 			page 19


 233 0042 0D4A     		ldr	r2, .L16+4
 234 0044 1268     		ldr	r2, [r2]
 235 0046 92F83650 		ldrb	r5, [r2, #54]	@ zero_extendqisi2
 121:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex       
 236              		.loc 1 121 28 view .LVU76
 237 004a 2B43     		orrs	r3, r3, r5
 238 004c 2381     		strh	r3, [r4, #8]	@ movhi
 122:uCOSII/Source/os_mutex.c ****         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
 239              		.loc 1 122 9 is_stmt 1 view .LVU77
 122:uCOSII/Source/os_mutex.c ****         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
 240              		.loc 1 122 29 is_stmt 0 view .LVU78
 241 004e 6260     		str	r2, [r4, #4]
 123:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...  
 242              		.loc 1 123 9 is_stmt 1 view .LVU79
 123:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...  
 243              		.loc 1 123 12 is_stmt 0 view .LVU80
 244 0050 FF29     		cmp	r1, #255
 245 0052 03D0     		beq	.L11
 124:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();                       /*      ... than current task!              
 246              		.loc 1 124 22 discriminator 1 view .LVU81
 247 0054 92F83630 		ldrb	r3, [r2, #54]	@ zero_extendqisi2
 123:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...  
 248              		.loc 1 123 45 discriminator 1 view .LVU82
 249 0058 8B42     		cmp	r3, r1
 250 005a 05D9     		bls	.L15
 251              	.L11:
 128:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_NONE;
 252              		.loc 1 128 14 is_stmt 1 view .LVU83
 253 005c FFF7FEFF 		bl	OS_CPU_SR_Restore
 254              	.LVL12:
 128:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_NONE;
 255              		.loc 1 128 32 view .LVU84
 129:uCOSII/Source/os_mutex.c ****         }
 256              		.loc 1 129 13 view .LVU85
 129:uCOSII/Source/os_mutex.c ****         }
 257              		.loc 1 129 19 is_stmt 0 view .LVU86
 258 0060 0023     		movs	r3, #0
 259 0062 3370     		strb	r3, [r6]
 260              	.L12:
 131:uCOSII/Source/os_mutex.c ****     }
 261              		.loc 1 131 9 is_stmt 1 view .LVU87
 131:uCOSII/Source/os_mutex.c ****     }
 262              		.loc 1 131 16 is_stmt 0 view .LVU88
 263 0064 0125     		movs	r5, #1
 264 0066 D3E7     		b	.L8
 265              	.LVL13:
 266              	.L15:
 125:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_PCP_LOWER;
 267              		.loc 1 125 14 is_stmt 1 view .LVU89
 268 0068 FFF7FEFF 		bl	OS_CPU_SR_Restore
 269              	.LVL14:
 125:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_PCP_LOWER;
 270              		.loc 1 125 32 view .LVU90
 126:uCOSII/Source/os_mutex.c ****         } else {
 271              		.loc 1 126 13 view .LVU91
 126:uCOSII/Source/os_mutex.c ****         } else {
 272              		.loc 1 126 19 is_stmt 0 view .LVU92
ARM GAS  /tmp/ccyWPqe2.s 			page 20


 273 006c 7823     		movs	r3, #120
 274 006e 3370     		strb	r3, [r6]
 275 0070 F8E7     		b	.L12
 276              	.L17:
 277 0072 00BF     		.align	2
 278              	.L16:
 279 0074 00000000 		.word	OSIntNesting
 280 0078 00000000 		.word	OSTCBCur
 281              		.cfi_endproc
 282              	.LFE0:
 284              		.section	.rodata.OSMutexCreate.str1.4,"aMS",%progbits,1
 285              		.align	2
 286              	.LC0:
 287 0000 3F00     		.ascii	"?\000"
 288              		.section	.text.OSMutexCreate,"ax",%progbits
 289              		.align	1
 290              		.global	OSMutexCreate
 291              		.syntax unified
 292              		.thumb
 293              		.thumb_func
 294              		.fpu fpv4-sp-d16
 296              	OSMutexCreate:
 297              	.LVL15:
 298              	.LFB1:
 179:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent;
 299              		.loc 1 179 1 is_stmt 1 view -0
 300              		.cfi_startproc
 301              		@ args = 0, pretend = 0, frame = 0
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 179:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent;
 303              		.loc 1 179 1 is_stmt 0 view .LVU94
 304 0000 70B5     		push	{r4, r5, r6, lr}
 305              	.LCFI3:
 306              		.cfi_def_cfa_offset 16
 307              		.cfi_offset 4, -16
 308              		.cfi_offset 5, -12
 309              		.cfi_offset 6, -8
 310              		.cfi_offset 14, -4
 311 0002 0E46     		mov	r6, r1
 180:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status regis
 312              		.loc 1 180 5 is_stmt 1 view .LVU95
 182:uCOSII/Source/os_mutex.c **** #endif
 313              		.loc 1 182 5 view .LVU96
 314              	.LVL16:
 209:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR   
 315              		.loc 1 209 5 view .LVU97
 209:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR   
 316              		.loc 1 209 22 is_stmt 0 view .LVU98
 317 0004 1E4B     		ldr	r3, .L29
 318 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 209:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR   
 319              		.loc 1 209 8 view .LVU99
 320 0008 23BB     		cbnz	r3, .L26
 321 000a 0446     		mov	r4, r0
 213:uCOSII/Source/os_mutex.c ****     if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 322              		.loc 1 213 5 is_stmt 1 view .LVU100
 323 000c FFF7FEFF 		bl	OS_CPU_SR_Save
ARM GAS  /tmp/ccyWPqe2.s 			page 21


 324              	.LVL17:
 213:uCOSII/Source/os_mutex.c ****     if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 325              		.loc 1 213 24 view .LVU101
 214:uCOSII/Source/os_mutex.c ****         if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist
 326              		.loc 1 214 5 view .LVU102
 214:uCOSII/Source/os_mutex.c ****         if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist
 327              		.loc 1 214 8 is_stmt 0 view .LVU103
 328 0010 FF2C     		cmp	r4, #255
 329 0012 07D0     		beq	.L21
 215:uCOSII/Source/os_mutex.c ****             OS_EXIT_CRITICAL();                            /* Task already exist at priority ...   
 330              		.loc 1 215 9 is_stmt 1 view .LVU104
 215:uCOSII/Source/os_mutex.c ****             OS_EXIT_CRITICAL();                            /* Task already exist at priority ...   
 331              		.loc 1 215 25 is_stmt 0 view .LVU105
 332 0014 1B4B     		ldr	r3, .L29+4
 333 0016 53F82430 		ldr	r3, [r3, r4, lsl #2]
 215:uCOSII/Source/os_mutex.c ****             OS_EXIT_CRITICAL();                            /* Task already exist at priority ...   
 334              		.loc 1 215 12 view .LVU106
 335 001a FBB9     		cbnz	r3, .L27
 220:uCOSII/Source/os_mutex.c ****     }
 336              		.loc 1 220 9 is_stmt 1 view .LVU107
 220:uCOSII/Source/os_mutex.c ****     }
 337              		.loc 1 220 28 is_stmt 0 view .LVU108
 338 001c 194B     		ldr	r3, .L29+4
 339 001e 0122     		movs	r2, #1
 340 0020 43F82420 		str	r2, [r3, r4, lsl #2]
 341              	.L21:
 223:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available          
 342              		.loc 1 223 5 is_stmt 1 view .LVU109
 223:uCOSII/Source/os_mutex.c ****     if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available          
 343              		.loc 1 223 12 is_stmt 0 view .LVU110
 344 0024 184B     		ldr	r3, .L29+8
 345 0026 1D68     		ldr	r5, [r3]
 346              	.LVL18:
 224:uCOSII/Source/os_mutex.c ****         if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 347              		.loc 1 224 5 is_stmt 1 view .LVU111
 224:uCOSII/Source/os_mutex.c ****         if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
 348              		.loc 1 224 8 is_stmt 0 view .LVU112
 349 0028 F5B1     		cbz	r5, .L28
 232:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 350              		.loc 1 232 5 is_stmt 1 view .LVU113
 232:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 351              		.loc 1 232 54 is_stmt 0 view .LVU114
 352 002a 6A68     		ldr	r2, [r5, #4]
 232:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 353              		.loc 1 232 25 view .LVU115
 354 002c 164B     		ldr	r3, .L29+8
 355 002e 1A60     		str	r2, [r3]
 233:uCOSII/Source/os_mutex.c ****     pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
 356              		.loc 1 233 5 is_stmt 1 view .LVU116
 357 0030 FFF7FEFF 		bl	OS_CPU_SR_Restore
 358              	.LVL19:
 233:uCOSII/Source/os_mutex.c ****     pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
 359              		.loc 1 233 23 view .LVU117
 234:uCOSII/Source/os_mutex.c ****     pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail. 
 360              		.loc 1 234 5 view .LVU118
 234:uCOSII/Source/os_mutex.c ****     pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail. 
 361              		.loc 1 234 25 is_stmt 0 view .LVU119
ARM GAS  /tmp/ccyWPqe2.s 			page 22


 362 0034 0423     		movs	r3, #4
 363 0036 2B70     		strb	r3, [r5]
 235:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex             
 364              		.loc 1 235 5 is_stmt 1 view .LVU120
 235:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex             
 365              		.loc 1 235 27 is_stmt 0 view .LVU121
 366 0038 2402     		lsls	r4, r4, #8
 235:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex             
 367              		.loc 1 235 25 view .LVU122
 368 003a 44F0FF04 		orr	r4, r4, #255
 369 003e 2C81     		strh	r4, [r5, #8]	@ movhi
 236:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 370              		.loc 1 236 5 is_stmt 1 view .LVU123
 236:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 371              		.loc 1 236 25 is_stmt 0 view .LVU124
 372 0040 0024     		movs	r4, #0
 373 0042 6C60     		str	r4, [r5, #4]
 238:uCOSII/Source/os_mutex.c **** #endif
 374              		.loc 1 238 5 is_stmt 1 view .LVU125
 238:uCOSII/Source/os_mutex.c **** #endif
 375              		.loc 1 238 25 is_stmt 0 view .LVU126
 376 0044 114B     		ldr	r3, .L29+12
 377 0046 6B61     		str	r3, [r5, #20]
 240:uCOSII/Source/os_mutex.c ****    *perr = OS_ERR_NONE;
 378              		.loc 1 240 5 is_stmt 1 view .LVU127
 379 0048 2846     		mov	r0, r5
 380 004a FFF7FEFF 		bl	OS_EventWaitListInit
 381              	.LVL20:
 241:uCOSII/Source/os_mutex.c ****     return (pevent);
 382              		.loc 1 241 4 view .LVU128
 241:uCOSII/Source/os_mutex.c ****     return (pevent);
 383              		.loc 1 241 10 is_stmt 0 view .LVU129
 384 004e 3470     		strb	r4, [r6]
 242:uCOSII/Source/os_mutex.c **** }
 385              		.loc 1 242 5 is_stmt 1 view .LVU130
 386              	.LVL21:
 387              	.L18:
 243:uCOSII/Source/os_mutex.c **** 
 388              		.loc 1 243 1 is_stmt 0 view .LVU131
 389 0050 2846     		mov	r0, r5
 390 0052 70BD     		pop	{r4, r5, r6, pc}
 391              	.LVL22:
 392              	.L26:
 210:uCOSII/Source/os_mutex.c ****         return ((OS_EVENT *)0);
 393              		.loc 1 210 9 is_stmt 1 view .LVU132
 210:uCOSII/Source/os_mutex.c ****         return ((OS_EVENT *)0);
 394              		.loc 1 210 15 is_stmt 0 view .LVU133
 395 0054 1023     		movs	r3, #16
 396 0056 0B70     		strb	r3, [r1]
 211:uCOSII/Source/os_mutex.c ****     }
 397              		.loc 1 211 9 is_stmt 1 view .LVU134
 211:uCOSII/Source/os_mutex.c ****     }
 398              		.loc 1 211 16 is_stmt 0 view .LVU135
 399 0058 0025     		movs	r5, #0
 400 005a F9E7     		b	.L18
 401              	.LVL23:
 402              	.L27:
ARM GAS  /tmp/ccyWPqe2.s 			page 23


 216:uCOSII/Source/os_mutex.c ****            *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                 
 403              		.loc 1 216 13 is_stmt 1 view .LVU136
 404 005c FFF7FEFF 		bl	OS_CPU_SR_Restore
 405              	.LVL24:
 216:uCOSII/Source/os_mutex.c ****            *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                 
 406              		.loc 1 216 31 view .LVU137
 217:uCOSII/Source/os_mutex.c ****             return ((OS_EVENT *)0);
 407              		.loc 1 217 12 view .LVU138
 217:uCOSII/Source/os_mutex.c ****             return ((OS_EVENT *)0);
 408              		.loc 1 217 18 is_stmt 0 view .LVU139
 409 0060 2823     		movs	r3, #40
 410 0062 3370     		strb	r3, [r6]
 218:uCOSII/Source/os_mutex.c ****         }
 411              		.loc 1 218 13 is_stmt 1 view .LVU140
 218:uCOSII/Source/os_mutex.c ****         }
 412              		.loc 1 218 20 is_stmt 0 view .LVU141
 413 0064 0025     		movs	r5, #0
 414 0066 F3E7     		b	.L18
 415              	.LVL25:
 416              	.L28:
 225:uCOSII/Source/os_mutex.c ****             OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry          
 417              		.loc 1 225 9 is_stmt 1 view .LVU142
 225:uCOSII/Source/os_mutex.c ****             OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry          
 418              		.loc 1 225 12 is_stmt 0 view .LVU143
 419 0068 FF2C     		cmp	r4, #255
 420 006a 03D0     		beq	.L24
 226:uCOSII/Source/os_mutex.c ****         }
 421              		.loc 1 226 13 is_stmt 1 view .LVU144
 226:uCOSII/Source/os_mutex.c ****         }
 422              		.loc 1 226 32 is_stmt 0 view .LVU145
 423 006c 054B     		ldr	r3, .L29+4
 424 006e 0022     		movs	r2, #0
 425 0070 43F82420 		str	r2, [r3, r4, lsl #2]
 426              	.L24:
 228:uCOSII/Source/os_mutex.c ****        *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks         
 427              		.loc 1 228 9 is_stmt 1 view .LVU146
 428 0074 FFF7FEFF 		bl	OS_CPU_SR_Restore
 429              	.LVL26:
 228:uCOSII/Source/os_mutex.c ****        *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks         
 430              		.loc 1 228 27 view .LVU147
 229:uCOSII/Source/os_mutex.c ****         return (pevent);
 431              		.loc 1 229 8 view .LVU148
 229:uCOSII/Source/os_mutex.c ****         return (pevent);
 432              		.loc 1 229 14 is_stmt 0 view .LVU149
 433 0078 0423     		movs	r3, #4
 434 007a 3370     		strb	r3, [r6]
 230:uCOSII/Source/os_mutex.c ****     }
 435              		.loc 1 230 9 is_stmt 1 view .LVU150
 230:uCOSII/Source/os_mutex.c ****     }
 436              		.loc 1 230 16 is_stmt 0 view .LVU151
 437 007c E8E7     		b	.L18
 438              	.L30:
 439 007e 00BF     		.align	2
 440              	.L29:
 441 0080 00000000 		.word	OSIntNesting
 442 0084 00000000 		.word	OSTCBPrioTbl
 443 0088 00000000 		.word	OSEventFreeList
ARM GAS  /tmp/ccyWPqe2.s 			page 24


 444 008c 00000000 		.word	.LC0
 445              		.cfi_endproc
 446              	.LFE1:
 448              		.section	.text.OSMutexDel,"ax",%progbits
 449              		.align	1
 450              		.global	OSMutexDel
 451              		.syntax unified
 452              		.thumb
 453              		.thumb_func
 454              		.fpu fpv4-sp-d16
 456              	OSMutexDel:
 457              	.LVL27:
 458              	.LFB2:
 290:uCOSII/Source/os_mutex.c ****     BOOLEAN    tasks_waiting;
 459              		.loc 1 290 1 is_stmt 1 view -0
 460              		.cfi_startproc
 461              		@ args = 0, pretend = 0, frame = 0
 462              		@ frame_needed = 0, uses_anonymous_args = 0
 290:uCOSII/Source/os_mutex.c ****     BOOLEAN    tasks_waiting;
 463              		.loc 1 290 1 is_stmt 0 view .LVU153
 464 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 465              	.LCFI4:
 466              		.cfi_def_cfa_offset 24
 467              		.cfi_offset 4, -24
 468              		.cfi_offset 5, -20
 469              		.cfi_offset 6, -16
 470              		.cfi_offset 7, -12
 471              		.cfi_offset 8, -8
 472              		.cfi_offset 14, -4
 473 0004 0446     		mov	r4, r0
 474 0006 1546     		mov	r5, r2
 291:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent_return;
 475              		.loc 1 291 5 is_stmt 1 view .LVU154
 292:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                        /* Priority ceiling priority            
 476              		.loc 1 292 5 view .LVU155
 293:uCOSII/Source/os_mutex.c ****     INT8U      prio;
 477              		.loc 1 293 5 view .LVU156
 294:uCOSII/Source/os_mutex.c ****     OS_TCB    *ptcb;
 478              		.loc 1 294 5 view .LVU157
 295:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status regis
 479              		.loc 1 295 5 view .LVU158
 297:uCOSII/Source/os_mutex.c **** #endif
 480              		.loc 1 297 5 view .LVU159
 481              	.LVL28:
 315:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 482              		.loc 1 315 5 view .LVU160
 315:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 483              		.loc 1 315 15 is_stmt 0 view .LVU161
 484 0008 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 315:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 485              		.loc 1 315 8 view .LVU162
 486 000a 042B     		cmp	r3, #4
 487 000c 03D0     		beq	.L32
 316:uCOSII/Source/os_mutex.c ****         return (pevent);
 488              		.loc 1 316 9 is_stmt 1 view .LVU163
 316:uCOSII/Source/os_mutex.c ****         return (pevent);
 489              		.loc 1 316 15 is_stmt 0 view .LVU164
ARM GAS  /tmp/ccyWPqe2.s 			page 25


 490 000e 0123     		movs	r3, #1
 491 0010 1370     		strb	r3, [r2]
 317:uCOSII/Source/os_mutex.c ****     }
 492              		.loc 1 317 9 is_stmt 1 view .LVU165
 493              	.LVL29:
 494              	.L31:
 393:uCOSII/Source/os_mutex.c **** #endif
 495              		.loc 1 393 1 is_stmt 0 view .LVU166
 496 0012 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 497              	.LVL30:
 498              	.L32:
 393:uCOSII/Source/os_mutex.c **** #endif
 499              		.loc 1 393 1 view .LVU167
 500 0016 0E46     		mov	r6, r1
 319:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR        
 501              		.loc 1 319 5 is_stmt 1 view .LVU168
 319:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR        
 502              		.loc 1 319 22 is_stmt 0 view .LVU169
 503 0018 374B     		ldr	r3, .L50
 504 001a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 319:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR        
 505              		.loc 1 319 8 view .LVU170
 506 001c 13B1     		cbz	r3, .L34
 320:uCOSII/Source/os_mutex.c ****         return (pevent);
 507              		.loc 1 320 9 is_stmt 1 view .LVU171
 320:uCOSII/Source/os_mutex.c ****         return (pevent);
 508              		.loc 1 320 15 is_stmt 0 view .LVU172
 509 001e 0F23     		movs	r3, #15
 510 0020 1370     		strb	r3, [r2]
 321:uCOSII/Source/os_mutex.c ****     }
 511              		.loc 1 321 9 is_stmt 1 view .LVU173
 321:uCOSII/Source/os_mutex.c ****     }
 512              		.loc 1 321 16 is_stmt 0 view .LVU174
 513 0022 F6E7     		b	.L31
 514              	.L34:
 323:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex    
 515              		.loc 1 323 5 is_stmt 1 view .LVU175
 516 0024 FFF7FEFF 		bl	OS_CPU_SR_Save
 517              	.LVL31:
 323:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex    
 518              		.loc 1 323 5 is_stmt 0 view .LVU176
 519 0028 0746     		mov	r7, r0
 520              	.LVL32:
 323:uCOSII/Source/os_mutex.c ****     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex    
 521              		.loc 1 323 24 is_stmt 1 view .LVU177
 324:uCOSII/Source/os_mutex.c ****         tasks_waiting = OS_TRUE;                           /* Yes                                  
 522              		.loc 1 324 5 view .LVU178
 324:uCOSII/Source/os_mutex.c ****         tasks_waiting = OS_TRUE;                           /* Yes                                  
 523              		.loc 1 324 15 is_stmt 0 view .LVU179
 524 002a 94F80A80 		ldrb	r8, [r4, #10]	@ zero_extendqisi2
 324:uCOSII/Source/os_mutex.c ****         tasks_waiting = OS_TRUE;                           /* Yes                                  
 525              		.loc 1 324 8 view .LVU180
 526 002e B8F1000F 		cmp	r8, #0
 527 0032 01D0     		beq	.L35
 325:uCOSII/Source/os_mutex.c ****     } else {
 528              		.loc 1 325 23 view .LVU181
 529 0034 4FF00108 		mov	r8, #1
ARM GAS  /tmp/ccyWPqe2.s 			page 26


 530              	.L35:
 531              	.LVL33:
 329:uCOSII/Source/os_mutex.c ****         case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING 
 532              		.loc 1 329 5 is_stmt 1 view .LVU182
 533 0038 46B1     		cbz	r6, .L36
 534 003a 012E     		cmp	r6, #1
 535 003c 27D0     		beq	.L37
 387:uCOSII/Source/os_mutex.c ****              *perr         = OS_ERR_INVALID_OPT;
 536              		.loc 1 387 14 view .LVU183
 537 003e 3846     		mov	r0, r7
 538              	.LVL34:
 387:uCOSII/Source/os_mutex.c ****              *perr         = OS_ERR_INVALID_OPT;
 539              		.loc 1 387 14 is_stmt 0 view .LVU184
 540 0040 FFF7FEFF 		bl	OS_CPU_SR_Restore
 541              	.LVL35:
 387:uCOSII/Source/os_mutex.c ****              *perr         = OS_ERR_INVALID_OPT;
 542              		.loc 1 387 32 is_stmt 1 view .LVU185
 388:uCOSII/Source/os_mutex.c ****              pevent_return = pevent;
 543              		.loc 1 388 14 view .LVU186
 388:uCOSII/Source/os_mutex.c ****              pevent_return = pevent;
 544              		.loc 1 388 28 is_stmt 0 view .LVU187
 545 0044 0723     		movs	r3, #7
 546 0046 2B70     		strb	r3, [r5]
 389:uCOSII/Source/os_mutex.c ****              break;
 547              		.loc 1 389 14 is_stmt 1 view .LVU188
 548              	.LVL36:
 390:uCOSII/Source/os_mutex.c ****     }
 549              		.loc 1 390 14 view .LVU189
 389:uCOSII/Source/os_mutex.c ****              break;
 550              		.loc 1 389 28 is_stmt 0 view .LVU190
 551 0048 2046     		mov	r0, r4
 552              	.LVL37:
 390:uCOSII/Source/os_mutex.c ****     }
 553              		.loc 1 390 14 view .LVU191
 554 004a E2E7     		b	.L31
 555              	.LVL38:
 556              	.L36:
 331:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 557              		.loc 1 331 14 is_stmt 1 view .LVU192
 331:uCOSII/Source/os_mutex.c **** #if OS_EVENT_NAME_EN > 0u
 558              		.loc 1 331 17 is_stmt 0 view .LVU193
 559 004c B8F1000F 		cmp	r8, #0
 560 0050 06D0     		beq	.L48
 347:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_TASK_WAITING;
 561              		.loc 1 347 18 is_stmt 1 view .LVU194
 562 0052 3846     		mov	r0, r7
 563              	.LVL39:
 347:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_TASK_WAITING;
 564              		.loc 1 347 18 is_stmt 0 view .LVU195
 565 0054 FFF7FEFF 		bl	OS_CPU_SR_Restore
 566              	.LVL40:
 347:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_TASK_WAITING;
 567              		.loc 1 347 36 is_stmt 1 view .LVU196
 348:uCOSII/Source/os_mutex.c ****                  pevent_return         = pevent;
 568              		.loc 1 348 18 view .LVU197
 348:uCOSII/Source/os_mutex.c ****                  pevent_return         = pevent;
 569              		.loc 1 348 40 is_stmt 0 view .LVU198
ARM GAS  /tmp/ccyWPqe2.s 			page 27


 570 0058 4923     		movs	r3, #73
 571 005a 2B70     		strb	r3, [r5]
 349:uCOSII/Source/os_mutex.c ****              }
 572              		.loc 1 349 18 is_stmt 1 view .LVU199
 573              	.LVL41:
 349:uCOSII/Source/os_mutex.c ****              }
 574              		.loc 1 349 40 is_stmt 0 view .LVU200
 575 005c 2046     		mov	r0, r4
 576 005e D8E7     		b	.L31
 577              	.LVL42:
 578              	.L48:
 333:uCOSII/Source/os_mutex.c **** #endif
 579              		.loc 1 333 18 is_stmt 1 view .LVU201
 333:uCOSII/Source/os_mutex.c **** #endif
 580              		.loc 1 333 40 is_stmt 0 view .LVU202
 581 0060 264B     		ldr	r3, .L50+4
 582 0062 6361     		str	r3, [r4, #20]
 335:uCOSII/Source/os_mutex.c ****                  if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 583              		.loc 1 335 18 is_stmt 1 view .LVU203
 335:uCOSII/Source/os_mutex.c ****                  if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 584              		.loc 1 335 56 is_stmt 0 view .LVU204
 585 0064 2389     		ldrh	r3, [r4, #8]
 335:uCOSII/Source/os_mutex.c ****                  if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 586              		.loc 1 335 40 view .LVU205
 587 0066 1B0A     		lsrs	r3, r3, #8
 588              	.LVL43:
 336:uCOSII/Source/os_mutex.c ****                      OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                      
 589              		.loc 1 336 18 is_stmt 1 view .LVU206
 336:uCOSII/Source/os_mutex.c ****                      OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                      
 590              		.loc 1 336 21 is_stmt 0 view .LVU207
 591 0068 FF2B     		cmp	r3, #255
 592 006a 03D0     		beq	.L40
 337:uCOSII/Source/os_mutex.c ****                  }
 593              		.loc 1 337 22 is_stmt 1 view .LVU208
 337:uCOSII/Source/os_mutex.c ****                  }
 594              		.loc 1 337 40 is_stmt 0 view .LVU209
 595 006c 244A     		ldr	r2, .L50+8
 596 006e 0021     		movs	r1, #0
 597 0070 42F82310 		str	r1, [r2, r3, lsl #2]
 598              	.L40:
 339:uCOSII/Source/os_mutex.c ****                  pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free li
 599              		.loc 1 339 18 is_stmt 1 view .LVU210
 339:uCOSII/Source/os_mutex.c ****                  pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free li
 600              		.loc 1 339 40 is_stmt 0 view .LVU211
 601 0074 0026     		movs	r6, #0
 602 0076 2670     		strb	r6, [r4]
 340:uCOSII/Source/os_mutex.c ****                  pevent->OSEventCnt    = 0u;
 603              		.loc 1 340 18 is_stmt 1 view .LVU212
 340:uCOSII/Source/os_mutex.c ****                  pevent->OSEventCnt    = 0u;
 604              		.loc 1 340 40 is_stmt 0 view .LVU213
 605 0078 224B     		ldr	r3, .L50+12
 606              	.LVL44:
 340:uCOSII/Source/os_mutex.c ****                  pevent->OSEventCnt    = 0u;
 607              		.loc 1 340 40 view .LVU214
 608 007a 1A68     		ldr	r2, [r3]
 609 007c 6260     		str	r2, [r4, #4]
 341:uCOSII/Source/os_mutex.c ****                  OSEventFreeList       = pevent;
ARM GAS  /tmp/ccyWPqe2.s 			page 28


 610              		.loc 1 341 18 is_stmt 1 view .LVU215
 341:uCOSII/Source/os_mutex.c ****                  OSEventFreeList       = pevent;
 611              		.loc 1 341 40 is_stmt 0 view .LVU216
 612 007e 2681     		strh	r6, [r4, #8]	@ movhi
 342:uCOSII/Source/os_mutex.c ****                  OS_EXIT_CRITICAL();
 613              		.loc 1 342 18 is_stmt 1 view .LVU217
 342:uCOSII/Source/os_mutex.c ****                  OS_EXIT_CRITICAL();
 614              		.loc 1 342 40 is_stmt 0 view .LVU218
 615 0080 1C60     		str	r4, [r3]
 343:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_NONE;
 616              		.loc 1 343 18 is_stmt 1 view .LVU219
 617 0082 3846     		mov	r0, r7
 618              	.LVL45:
 343:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_NONE;
 619              		.loc 1 343 18 is_stmt 0 view .LVU220
 620 0084 FFF7FEFF 		bl	OS_CPU_SR_Restore
 621              	.LVL46:
 343:uCOSII/Source/os_mutex.c ****                  *perr                 = OS_ERR_NONE;
 622              		.loc 1 343 36 is_stmt 1 view .LVU221
 344:uCOSII/Source/os_mutex.c ****                  pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted               
 623              		.loc 1 344 18 view .LVU222
 344:uCOSII/Source/os_mutex.c ****                  pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted               
 624              		.loc 1 344 40 is_stmt 0 view .LVU223
 625 0088 2E70     		strb	r6, [r5]
 345:uCOSII/Source/os_mutex.c ****              } else {
 626              		.loc 1 345 18 is_stmt 1 view .LVU224
 627              	.LVL47:
 345:uCOSII/Source/os_mutex.c ****              } else {
 628              		.loc 1 345 40 is_stmt 0 view .LVU225
 629 008a 3046     		mov	r0, r6
 630 008c C1E7     		b	.L31
 631              	.LVL48:
 632              	.L37:
 354:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 633              		.loc 1 354 14 is_stmt 1 view .LVU226
 354:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 634              		.loc 1 354 35 is_stmt 0 view .LVU227
 635 008e 2189     		ldrh	r1, [r4, #8]
 354:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 636              		.loc 1 354 19 view .LVU228
 637 0090 0B0A     		lsrs	r3, r1, #8
 638              	.LVL49:
 355:uCOSII/Source/os_mutex.c ****                  prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig pr
 639              		.loc 1 355 14 is_stmt 1 view .LVU229
 355:uCOSII/Source/os_mutex.c ****                  prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig pr
 640              		.loc 1 355 17 is_stmt 0 view .LVU230
 641 0092 FF2B     		cmp	r3, #255
 642 0094 0FD0     		beq	.L42
 356:uCOSII/Source/os_mutex.c ****                  ptcb = (OS_TCB *)pevent->OSEventPtr;
 643              		.loc 1 356 18 is_stmt 1 view .LVU231
 356:uCOSII/Source/os_mutex.c ****                  ptcb = (OS_TCB *)pevent->OSEventPtr;
 644              		.loc 1 356 23 is_stmt 0 view .LVU232
 645 0096 C9B2     		uxtb	r1, r1
 646              	.LVL50:
 357:uCOSII/Source/os_mutex.c ****                  if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex       
 647              		.loc 1 357 18 is_stmt 1 view .LVU233
 357:uCOSII/Source/os_mutex.c ****                  if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex       
ARM GAS  /tmp/ccyWPqe2.s 			page 29


 648              		.loc 1 357 23 is_stmt 0 view .LVU234
 649 0098 6068     		ldr	r0, [r4, #4]
 650              	.LVL51:
 358:uCOSII/Source/os_mutex.c ****                      if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed     
 651              		.loc 1 358 18 is_stmt 1 view .LVU235
 358:uCOSII/Source/os_mutex.c ****                      if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed     
 652              		.loc 1 358 21 is_stmt 0 view .LVU236
 653 009a 60B1     		cbz	r0, .L42
 359:uCOSII/Source/os_mutex.c ****                          OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio
 654              		.loc 1 359 22 is_stmt 1 view .LVU237
 359:uCOSII/Source/os_mutex.c ****                          OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio
 655              		.loc 1 359 30 is_stmt 0 view .LVU238
 656 009c 90F83620 		ldrb	r2, [r0, #54]	@ zero_extendqisi2
 359:uCOSII/Source/os_mutex.c ****                          OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio
 657              		.loc 1 359 25 view .LVU239
 658 00a0 9A42     		cmp	r2, r3
 659 00a2 08D1     		bne	.L42
 360:uCOSII/Source/os_mutex.c ****                      }
 660              		.loc 1 360 26 is_stmt 1 view .LVU240
 661 00a4 FFF7FEFF 		bl	OSMutex_RdyAtPrio
 662              	.LVL52:
 360:uCOSII/Source/os_mutex.c ****                      }
 663              		.loc 1 360 26 is_stmt 0 view .LVU241
 664 00a8 05E0     		b	.L42
 665              	.L43:
 365:uCOSII/Source/os_mutex.c ****              }
 666              		.loc 1 365 18 is_stmt 1 view .LVU242
 365:uCOSII/Source/os_mutex.c ****              }
 667              		.loc 1 365 24 is_stmt 0 view .LVU243
 668 00aa 0223     		movs	r3, #2
 669 00ac 1022     		movs	r2, #16
 670 00ae 0021     		movs	r1, #0
 671 00b0 2046     		mov	r0, r4
 672 00b2 FFF7FEFF 		bl	OS_EventTaskRdy
 673              	.LVL53:
 674              	.L42:
 364:uCOSII/Source/os_mutex.c ****                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
 675              		.loc 1 364 20 is_stmt 1 view .LVU244
 364:uCOSII/Source/os_mutex.c ****                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
 676              		.loc 1 364 27 is_stmt 0 view .LVU245
 677 00b6 A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 364:uCOSII/Source/os_mutex.c ****                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
 678              		.loc 1 364 20 view .LVU246
 679 00b8 002B     		cmp	r3, #0
 680 00ba F6D1     		bne	.L43
 368:uCOSII/Source/os_mutex.c **** #endif
 681              		.loc 1 368 14 is_stmt 1 view .LVU247
 368:uCOSII/Source/os_mutex.c **** #endif
 682              		.loc 1 368 36 is_stmt 0 view .LVU248
 683 00bc 0F4B     		ldr	r3, .L50+4
 684 00be 6361     		str	r3, [r4, #20]
 370:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 685              		.loc 1 370 14 is_stmt 1 view .LVU249
 370:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
 686              		.loc 1 370 52 is_stmt 0 view .LVU250
 687 00c0 2389     		ldrh	r3, [r4, #8]
 370:uCOSII/Source/os_mutex.c ****              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
ARM GAS  /tmp/ccyWPqe2.s 			page 30


 688              		.loc 1 370 36 view .LVU251
 689 00c2 1B0A     		lsrs	r3, r3, #8
 690              	.LVL54:
 371:uCOSII/Source/os_mutex.c ****                  OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                      
 691              		.loc 1 371 14 is_stmt 1 view .LVU252
 371:uCOSII/Source/os_mutex.c ****                  OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                      
 692              		.loc 1 371 17 is_stmt 0 view .LVU253
 693 00c4 FF2B     		cmp	r3, #255
 694 00c6 03D0     		beq	.L44
 372:uCOSII/Source/os_mutex.c ****              }
 695              		.loc 1 372 18 is_stmt 1 view .LVU254
 372:uCOSII/Source/os_mutex.c ****              }
 696              		.loc 1 372 36 is_stmt 0 view .LVU255
 697 00c8 0D4A     		ldr	r2, .L50+8
 698 00ca 0021     		movs	r1, #0
 699 00cc 42F82310 		str	r1, [r2, r3, lsl #2]
 700              	.L44:
 374:uCOSII/Source/os_mutex.c ****              pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free li
 701              		.loc 1 374 14 is_stmt 1 view .LVU256
 374:uCOSII/Source/os_mutex.c ****              pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free li
 702              		.loc 1 374 36 is_stmt 0 view .LVU257
 703 00d0 0022     		movs	r2, #0
 704 00d2 2270     		strb	r2, [r4]
 375:uCOSII/Source/os_mutex.c ****              pevent->OSEventCnt    = 0u;
 705              		.loc 1 375 14 is_stmt 1 view .LVU258
 375:uCOSII/Source/os_mutex.c ****              pevent->OSEventCnt    = 0u;
 706              		.loc 1 375 36 is_stmt 0 view .LVU259
 707 00d4 0B4B     		ldr	r3, .L50+12
 708              	.LVL55:
 375:uCOSII/Source/os_mutex.c ****              pevent->OSEventCnt    = 0u;
 709              		.loc 1 375 36 view .LVU260
 710 00d6 1968     		ldr	r1, [r3]
 711 00d8 6160     		str	r1, [r4, #4]
 376:uCOSII/Source/os_mutex.c ****              OSEventFreeList       = pevent;               /* Get next free event control block    
 712              		.loc 1 376 14 is_stmt 1 view .LVU261
 376:uCOSII/Source/os_mutex.c ****              OSEventFreeList       = pevent;               /* Get next free event control block    
 713              		.loc 1 376 36 is_stmt 0 view .LVU262
 714 00da 2281     		strh	r2, [r4, #8]	@ movhi
 377:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();
 715              		.loc 1 377 14 is_stmt 1 view .LVU263
 377:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();
 716              		.loc 1 377 36 is_stmt 0 view .LVU264
 717 00dc 1C60     		str	r4, [r3]
 378:uCOSII/Source/os_mutex.c ****              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiti
 718              		.loc 1 378 14 is_stmt 1 view .LVU265
 719 00de 3846     		mov	r0, r7
 720 00e0 FFF7FEFF 		bl	OS_CPU_SR_Restore
 721              	.LVL56:
 378:uCOSII/Source/os_mutex.c ****              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiti
 722              		.loc 1 378 32 view .LVU266
 379:uCOSII/Source/os_mutex.c ****                  OS_Sched();                               /* Find highest priority task ready to r
 723              		.loc 1 379 14 view .LVU267
 379:uCOSII/Source/os_mutex.c ****                  OS_Sched();                               /* Find highest priority task ready to r
 724              		.loc 1 379 17 is_stmt 0 view .LVU268
 725 00e4 B8F1010F 		cmp	r8, #1
 726 00e8 03D0     		beq	.L49
 727              	.L45:
ARM GAS  /tmp/ccyWPqe2.s 			page 31


 382:uCOSII/Source/os_mutex.c ****              pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted               
 728              		.loc 1 382 14 is_stmt 1 view .LVU269
 382:uCOSII/Source/os_mutex.c ****              pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted               
 729              		.loc 1 382 28 is_stmt 0 view .LVU270
 730 00ea 0024     		movs	r4, #0
 731              	.LVL57:
 382:uCOSII/Source/os_mutex.c ****              pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted               
 732              		.loc 1 382 28 view .LVU271
 733 00ec 2C70     		strb	r4, [r5]
 383:uCOSII/Source/os_mutex.c ****              break;
 734              		.loc 1 383 14 is_stmt 1 view .LVU272
 735              	.LVL58:
 384:uCOSII/Source/os_mutex.c **** 
 736              		.loc 1 384 14 view .LVU273
 383:uCOSII/Source/os_mutex.c ****              break;
 737              		.loc 1 383 28 is_stmt 0 view .LVU274
 738 00ee 2046     		mov	r0, r4
 384:uCOSII/Source/os_mutex.c **** 
 739              		.loc 1 384 14 view .LVU275
 740 00f0 8FE7     		b	.L31
 741              	.LVL59:
 742              	.L49:
 380:uCOSII/Source/os_mutex.c ****              }
 743              		.loc 1 380 18 is_stmt 1 view .LVU276
 744 00f2 FFF7FEFF 		bl	OS_Sched
 745              	.LVL60:
 746 00f6 F8E7     		b	.L45
 747              	.L51:
 748              		.align	2
 749              	.L50:
 750 00f8 00000000 		.word	OSIntNesting
 751 00fc 00000000 		.word	.LC0
 752 0100 00000000 		.word	OSTCBPrioTbl
 753 0104 00000000 		.word	OSEventFreeList
 754              		.cfi_endproc
 755              	.LFE2:
 757              		.section	.text.OSMutexPend,"ax",%progbits
 758              		.align	1
 759              		.global	OSMutexPend
 760              		.syntax unified
 761              		.thumb
 762              		.thumb_func
 763              		.fpu fpv4-sp-d16
 765              	OSMutexPend:
 766              	.LVL61:
 767              	.LFB3:
 440:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)      
 768              		.loc 1 440 1 view -0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 0
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 440:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)      
 772              		.loc 1 440 1 is_stmt 0 view .LVU278
 773 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 774              	.LCFI5:
 775              		.cfi_def_cfa_offset 24
 776              		.cfi_offset 4, -24
ARM GAS  /tmp/ccyWPqe2.s 			page 32


 777              		.cfi_offset 5, -20
 778              		.cfi_offset 6, -16
 779              		.cfi_offset 7, -12
 780              		.cfi_offset 8, -8
 781              		.cfi_offset 14, -4
 782 0004 1546     		mov	r5, r2
 441:uCOSII/Source/os_mutex.c ****     INT8U      mprio;                                      /* Mutex owner priority                 
 783              		.loc 1 441 5 is_stmt 1 view .LVU279
 442:uCOSII/Source/os_mutex.c ****     BOOLEAN    rdy;                                        /* Flag indicating task was ready       
 784              		.loc 1 442 5 view .LVU280
 443:uCOSII/Source/os_mutex.c ****     OS_TCB    *ptcb;
 785              		.loc 1 443 5 view .LVU281
 444:uCOSII/Source/os_mutex.c ****     OS_EVENT  *pevent2;
 786              		.loc 1 444 5 view .LVU282
 445:uCOSII/Source/os_mutex.c ****     INT8U      y;
 787              		.loc 1 445 5 view .LVU283
 446:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status regis
 788              		.loc 1 446 5 view .LVU284
 448:uCOSII/Source/os_mutex.c **** #endif
 789              		.loc 1 448 5 view .LVU285
 790              	.LVL62:
 466:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 791              		.loc 1 466 5 view .LVU286
 466:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 792              		.loc 1 466 15 is_stmt 0 view .LVU287
 793 0006 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 466:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_EVENT_TYPE;
 794              		.loc 1 466 8 view .LVU288
 795 0008 042B     		cmp	r3, #4
 796 000a 03D0     		beq	.L53
 467:uCOSII/Source/os_mutex.c ****         return;
 797              		.loc 1 467 9 is_stmt 1 view .LVU289
 467:uCOSII/Source/os_mutex.c ****         return;
 798              		.loc 1 467 15 is_stmt 0 view .LVU290
 799 000c 0123     		movs	r3, #1
 800 000e 1370     		strb	r3, [r2]
 468:uCOSII/Source/os_mutex.c ****     }
 801              		.loc 1 468 9 is_stmt 1 view .LVU291
 802              	.LVL63:
 803              	.L52:
 573:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 804              		.loc 1 573 1 is_stmt 0 view .LVU292
 805 0010 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 806              	.LVL64:
 807              	.L53:
 573:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 808              		.loc 1 573 1 view .LVU293
 809 0014 0446     		mov	r4, r0
 810 0016 0E46     		mov	r6, r1
 470:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR           
 811              		.loc 1 470 5 is_stmt 1 view .LVU294
 470:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR           
 812              		.loc 1 470 22 is_stmt 0 view .LVU295
 813 0018 734B     		ldr	r3, .L76
 814 001a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 470:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR           
 815              		.loc 1 470 8 view .LVU296
ARM GAS  /tmp/ccyWPqe2.s 			page 33


 816 001c 2BB9     		cbnz	r3, .L72
 474:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked           
 817              		.loc 1 474 5 is_stmt 1 view .LVU297
 474:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked           
 818              		.loc 1 474 23 is_stmt 0 view .LVU298
 819 001e 734B     		ldr	r3, .L76+4
 820 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 474:uCOSII/Source/os_mutex.c ****         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked           
 821              		.loc 1 474 8 view .LVU299
 822 0022 2BB1     		cbz	r3, .L56
 475:uCOSII/Source/os_mutex.c ****         return;
 823              		.loc 1 475 9 is_stmt 1 view .LVU300
 475:uCOSII/Source/os_mutex.c ****         return;
 824              		.loc 1 475 15 is_stmt 0 view .LVU301
 825 0024 0D23     		movs	r3, #13
 826 0026 1370     		strb	r3, [r2]
 476:uCOSII/Source/os_mutex.c ****     }
 827              		.loc 1 476 9 is_stmt 1 view .LVU302
 828 0028 F2E7     		b	.L52
 829              	.L72:
 471:uCOSII/Source/os_mutex.c ****         return;
 830              		.loc 1 471 9 view .LVU303
 471:uCOSII/Source/os_mutex.c ****         return;
 831              		.loc 1 471 15 is_stmt 0 view .LVU304
 832 002a 0223     		movs	r3, #2
 833 002c 1370     		strb	r3, [r2]
 472:uCOSII/Source/os_mutex.c ****     }
 834              		.loc 1 472 9 is_stmt 1 view .LVU305
 835 002e EFE7     		b	.L52
 836              	.L56:
 479:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                   
 837              		.loc 1 479 5 view .LVU306
 838 0030 FFF7FEFF 		bl	OS_CPU_SR_Save
 839              	.LVL65:
 479:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                   
 840              		.loc 1 479 5 is_stmt 0 view .LVU307
 841 0034 0746     		mov	r7, r0
 842              	.LVL66:
 479:uCOSII/Source/os_mutex.c ****     pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                   
 843              		.loc 1 479 24 is_stmt 1 view .LVU308
 480:uCOSII/Source/os_mutex.c ****                                                            /* Is Mutex available?                  
 844              		.loc 1 480 5 view .LVU309
 480:uCOSII/Source/os_mutex.c ****                                                            /* Is Mutex available?                  
 845              		.loc 1 480 25 is_stmt 0 view .LVU310
 846 0036 2389     		ldrh	r3, [r4, #8]
 480:uCOSII/Source/os_mutex.c ****                                                            /* Is Mutex available?                  
 847              		.loc 1 480 9 view .LVU311
 848 0038 1A0A     		lsrs	r2, r3, #8
 849              	.LVL67:
 482:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource            
 850              		.loc 1 482 5 is_stmt 1 view .LVU312
 482:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource            
 851              		.loc 1 482 9 is_stmt 0 view .LVU313
 852 003a D9B2     		uxtb	r1, r3
 482:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource            
 853              		.loc 1 482 8 view .LVU314
 854 003c FF29     		cmp	r1, #255
ARM GAS  /tmp/ccyWPqe2.s 			page 34


 855 003e 7BD0     		beq	.L73
 496:uCOSII/Source/os_mutex.c ****         mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owne
 856              		.loc 1 496 5 is_stmt 1 view .LVU315
 496:uCOSII/Source/os_mutex.c ****         mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owne
 857              		.loc 1 496 8 is_stmt 0 view .LVU316
 858 0040 FF2A     		cmp	r2, #255
 859 0042 52D0     		beq	.L60
 497:uCOSII/Source/os_mutex.c ****         ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owne
 860              		.loc 1 497 9 is_stmt 1 view .LVU317
 861              	.LVL68:
 498:uCOSII/Source/os_mutex.c ****         if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of ow
 862              		.loc 1 498 9 view .LVU318
 498:uCOSII/Source/os_mutex.c ****         if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of ow
 863              		.loc 1 498 15 is_stmt 0 view .LVU319
 864 0044 6368     		ldr	r3, [r4, #4]
 865              	.LVL69:
 499:uCOSII/Source/os_mutex.c ****             if (mprio > OSTCBCur->OSTCBPrio) {
 866              		.loc 1 499 9 is_stmt 1 view .LVU320
 499:uCOSII/Source/os_mutex.c ****             if (mprio > OSTCBCur->OSTCBPrio) {
 867              		.loc 1 499 17 is_stmt 0 view .LVU321
 868 0046 93F83600 		ldrb	r0, [r3, #54]	@ zero_extendqisi2
 869              	.LVL70:
 499:uCOSII/Source/os_mutex.c ****             if (mprio > OSTCBCur->OSTCBPrio) {
 870              		.loc 1 499 12 view .LVU322
 871 004a 9042     		cmp	r0, r2
 872 004c 4DD9     		bls	.L60
 500:uCOSII/Source/os_mutex.c ****                 y = ptcb->OSTCBY;
 873              		.loc 1 500 13 is_stmt 1 view .LVU323
 500:uCOSII/Source/os_mutex.c ****                 y = ptcb->OSTCBY;
 874              		.loc 1 500 33 is_stmt 0 view .LVU324
 875 004e 6848     		ldr	r0, .L76+8
 876 0050 0068     		ldr	r0, [r0]
 877 0052 90F83600 		ldrb	r0, [r0, #54]	@ zero_extendqisi2
 500:uCOSII/Source/os_mutex.c ****                 y = ptcb->OSTCBY;
 878              		.loc 1 500 16 view .LVU325
 879 0056 8142     		cmp	r1, r0
 880 0058 47D9     		bls	.L60
 501:uCOSII/Source/os_mutex.c ****                 if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is read
 881              		.loc 1 501 17 is_stmt 1 view .LVU326
 501:uCOSII/Source/os_mutex.c ****                 if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is read
 882              		.loc 1 501 19 is_stmt 0 view .LVU327
 883 005a 93F83800 		ldrb	r0, [r3, #56]	@ zero_extendqisi2
 884              	.LVL71:
 502:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy
 885              		.loc 1 502 17 is_stmt 1 view .LVU328
 502:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy
 886              		.loc 1 502 30 is_stmt 0 view .LVU329
 887 005e 6549     		ldr	r1, .L76+12
 888              	.LVL72:
 502:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy
 889              		.loc 1 502 30 view .LVU330
 890 0060 095C     		ldrb	r1, [r1, r0]	@ zero_extendqisi2
 502:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy
 891              		.loc 1 502 40 view .LVU331
 892 0062 93F839C0 		ldrb	ip, [r3, #57]	@ zero_extendqisi2
 502:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy
 893              		.loc 1 502 20 view .LVU332
ARM GAS  /tmp/ccyWPqe2.s 			page 35


 894 0066 11EA0C0E 		ands	lr, r1, ip
 895 006a 00F08180 		beq	.L61
 503:uCOSII/Source/os_mutex.c ****                     if (OSRdyTbl[y] == 0u) {                      /*          ... list at current p
 896              		.loc 1 503 21 is_stmt 1 view .LVU333
 503:uCOSII/Source/os_mutex.c ****                     if (OSRdyTbl[y] == 0u) {                      /*          ... list at current p
 897              		.loc 1 503 33 is_stmt 0 view .LVU334
 898 006e 21EA0C01 		bic	r1, r1, ip
 899 0072 DFF880C1 		ldr	ip, .L76+12
 900 0076 0CF80010 		strb	r1, [ip, r0]
 504:uCOSII/Source/os_mutex.c ****                         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 901              		.loc 1 504 21 is_stmt 1 view .LVU335
 504:uCOSII/Source/os_mutex.c ****                         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 902              		.loc 1 504 24 is_stmt 0 view .LVU336
 903 007a 0029     		cmp	r1, #0
 904 007c 40F08E80 		bne	.L69
 505:uCOSII/Source/os_mutex.c ****                     }
 905              		.loc 1 505 25 is_stmt 1 view .LVU337
 505:uCOSII/Source/os_mutex.c ****                     }
 906              		.loc 1 505 51 is_stmt 0 view .LVU338
 907 0080 93F83AC0 		ldrb	ip, [r3, #58]	@ zero_extendqisi2
 505:uCOSII/Source/os_mutex.c ****                     }
 908              		.loc 1 505 34 view .LVU339
 909 0084 5C48     		ldr	r0, .L76+16
 910              	.LVL73:
 505:uCOSII/Source/os_mutex.c ****                     }
 911              		.loc 1 505 34 view .LVU340
 912 0086 0178     		ldrb	r1, [r0]	@ zero_extendqisi2
 913 0088 21EA0C01 		bic	r1, r1, ip
 914 008c 0170     		strb	r1, [r0]
 507:uCOSII/Source/os_mutex.c ****                 } else {
 915              		.loc 1 507 25 view .LVU341
 916 008e 4FF0010E 		mov	lr, #1
 917              	.LVL74:
 918              	.L62:
 519:uCOSII/Source/os_mutex.c **** #if OS_LOWEST_PRIO <= 63u
 919              		.loc 1 519 17 is_stmt 1 view .LVU342
 519:uCOSII/Source/os_mutex.c **** #if OS_LOWEST_PRIO <= 63u
 920              		.loc 1 519 33 is_stmt 0 view .LVU343
 921 0092 83F83620 		strb	r2, [r3, #54]
 521:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
 922              		.loc 1 521 17 is_stmt 1 view .LVU344
 521:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
 923              		.loc 1 521 35 is_stmt 0 view .LVU345
 924 0096 4FEAD20C 		lsr	ip, r2, #3
 521:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
 925              		.loc 1 521 33 view .LVU346
 926 009a 83F838C0 		strb	ip, [r3, #56]
 522:uCOSII/Source/os_mutex.c **** #else
 927              		.loc 1 522 17 is_stmt 1 view .LVU347
 522:uCOSII/Source/os_mutex.c **** #else
 928              		.loc 1 522 35 is_stmt 0 view .LVU348
 929 009e 02F00708 		and	r8, r2, #7
 522:uCOSII/Source/os_mutex.c **** #else
 930              		.loc 1 522 33 view .LVU349
 931 00a2 83F83780 		strb	r8, [r3, #55]
 527:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
 932              		.loc 1 527 17 is_stmt 1 view .LVU350
ARM GAS  /tmp/ccyWPqe2.s 			page 36


 527:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
 933              		.loc 1 527 49 is_stmt 0 view .LVU351
 934 00a6 0121     		movs	r1, #1
 935 00a8 01FA0CF0 		lsl	r0, r1, ip
 527:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
 936              		.loc 1 527 35 view .LVU352
 937 00ac C0B2     		uxtb	r0, r0
 527:uCOSII/Source/os_mutex.c ****                 ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
 938              		.loc 1 527 33 view .LVU353
 939 00ae 83F83A00 		strb	r0, [r3, #58]
 528:uCOSII/Source/os_mutex.c **** 
 940              		.loc 1 528 17 is_stmt 1 view .LVU354
 528:uCOSII/Source/os_mutex.c **** 
 941              		.loc 1 528 49 is_stmt 0 view .LVU355
 942 00b2 01FA08F1 		lsl	r1, r1, r8
 528:uCOSII/Source/os_mutex.c **** 
 943              		.loc 1 528 35 view .LVU356
 944 00b6 C9B2     		uxtb	r1, r1
 528:uCOSII/Source/os_mutex.c **** 
 945              		.loc 1 528 33 view .LVU357
 946 00b8 83F83910 		strb	r1, [r3, #57]
 530:uCOSII/Source/os_mutex.c ****                     OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority
 947              		.loc 1 530 17 is_stmt 1 view .LVU358
 530:uCOSII/Source/os_mutex.c ****                     OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority
 948              		.loc 1 530 20 is_stmt 0 view .LVU359
 949 00bc BEF1010F 		cmp	lr, #1
 950 00c0 6FD0     		beq	.L74
 534:uCOSII/Source/os_mutex.c ****                     if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list               
 951              		.loc 1 534 21 is_stmt 1 view .LVU360
 534:uCOSII/Source/os_mutex.c ****                     if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list               
 952              		.loc 1 534 29 is_stmt 0 view .LVU361
 953 00c2 D969     		ldr	r1, [r3, #28]
 954              	.LVL75:
 535:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
 955              		.loc 1 535 21 is_stmt 1 view .LVU362
 535:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
 956              		.loc 1 535 24 is_stmt 0 view .LVU363
 957 00c4 71B1     		cbz	r1, .L64
 536:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 958              		.loc 1 536 25 is_stmt 1 view .LVU364
 536:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 959              		.loc 1 536 59 is_stmt 0 view .LVU365
 960 00c6 91F80AC0 		ldrb	ip, [r1, #10]	@ zero_extendqisi2
 961 00ca 40EA0C00 		orr	r0, r0, ip
 962 00ce 8872     		strb	r0, [r1, #10]
 537:uCOSII/Source/os_mutex.c ****                     }
 963              		.loc 1 537 25 is_stmt 1 view .LVU366
 537:uCOSII/Source/os_mutex.c ****                     }
 964              		.loc 1 537 49 is_stmt 0 view .LVU367
 965 00d0 93F838C0 		ldrb	ip, [r3, #56]	@ zero_extendqisi2
 537:uCOSII/Source/os_mutex.c ****                     }
 966              		.loc 1 537 66 view .LVU368
 967 00d4 93F83900 		ldrb	r0, [r3, #57]	@ zero_extendqisi2
 537:uCOSII/Source/os_mutex.c ****                     }
 968              		.loc 1 537 59 view .LVU369
 969 00d8 6144     		add	r1, r1, ip
 970              	.LVL76:
ARM GAS  /tmp/ccyWPqe2.s 			page 37


 537:uCOSII/Source/os_mutex.c ****                     }
 971              		.loc 1 537 59 view .LVU370
 972 00da 91F80BC0 		ldrb	ip, [r1, #11]	@ zero_extendqisi2
 973 00de 40EA0C00 		orr	r0, r0, ip
 974 00e2 C872     		strb	r0, [r1, #11]
 975              	.LVL77:
 976              	.L64:
 540:uCOSII/Source/os_mutex.c ****             }
 977              		.loc 1 540 17 is_stmt 1 view .LVU371
 540:uCOSII/Source/os_mutex.c ****             }
 978              		.loc 1 540 35 is_stmt 0 view .LVU372
 979 00e4 4549     		ldr	r1, .L76+20
 980 00e6 41F82230 		str	r3, [r1, r2, lsl #2]
 981              	.LVL78:
 982              	.L60:
 544:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 983              		.loc 1 544 5 is_stmt 1 view .LVU373
 544:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 984              		.loc 1 544 29 is_stmt 0 view .LVU374
 985 00ea DFF80481 		ldr	r8, .L76+8
 986 00ee D8F80030 		ldr	r3, [r8]
 987 00f2 93F83420 		ldrb	r2, [r3, #52]	@ zero_extendqisi2
 988              	.LVL79:
 544:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 989              		.loc 1 544 29 view .LVU375
 990 00f6 42F01002 		orr	r2, r2, #16
 991 00fa 83F83420 		strb	r2, [r3, #52]
 545:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB       
 992              		.loc 1 545 5 is_stmt 1 view .LVU376
 545:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB       
 993              		.loc 1 545 30 is_stmt 0 view .LVU377
 994 00fe 0022     		movs	r2, #0
 995 0100 83F83520 		strb	r2, [r3, #53]
 546:uCOSII/Source/os_mutex.c ****     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs
 996              		.loc 1 546 5 is_stmt 1 view .LVU378
 546:uCOSII/Source/os_mutex.c ****     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs
 997              		.loc 1 546 30 is_stmt 0 view .LVU379
 998 0104 1E63     		str	r6, [r3, #48]
 547:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 999              		.loc 1 547 5 is_stmt 1 view .LVU380
 1000 0106 2046     		mov	r0, r4
 1001 0108 FFF7FEFF 		bl	OS_EventTaskWait
 1002              	.LVL80:
 548:uCOSII/Source/os_mutex.c ****     OS_Sched();                                       /* Find next highest priority task ready     
 1003              		.loc 1 548 5 view .LVU381
 1004 010c 3846     		mov	r0, r7
 1005 010e FFF7FEFF 		bl	OS_CPU_SR_Restore
 1006              	.LVL81:
 548:uCOSII/Source/os_mutex.c ****     OS_Sched();                                       /* Find next highest priority task ready     
 1007              		.loc 1 548 23 view .LVU382
 549:uCOSII/Source/os_mutex.c ****     OS_ENTER_CRITICAL();
 1008              		.loc 1 549 5 view .LVU383
 1009 0112 FFF7FEFF 		bl	OS_Sched
 1010              	.LVL82:
 550:uCOSII/Source/os_mutex.c ****     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted            
 1011              		.loc 1 550 5 view .LVU384
 1012 0116 FFF7FEFF 		bl	OS_CPU_SR_Save
ARM GAS  /tmp/ccyWPqe2.s 			page 38


 1013              	.LVL83:
 1014 011a 0646     		mov	r6, r0
 1015              	.LVL84:
 550:uCOSII/Source/os_mutex.c ****     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted            
 1016              		.loc 1 550 24 view .LVU385
 551:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_OK:
 1017              		.loc 1 551 5 view .LVU386
 551:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_OK:
 1018              		.loc 1 551 21 is_stmt 0 view .LVU387
 1019 011c D8F80000 		ldr	r0, [r8]
 1020              	.LVL85:
 551:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_OK:
 1021              		.loc 1 551 21 view .LVU388
 1022 0120 90F83530 		ldrb	r3, [r0, #53]	@ zero_extendqisi2
 551:uCOSII/Source/os_mutex.c ****         case OS_STAT_PEND_OK:
 1023              		.loc 1 551 5 view .LVU389
 1024 0124 002B     		cmp	r3, #0
 1025 0126 4CD0     		beq	.L65
 1026 0128 022B     		cmp	r3, #2
 1027 012a 59D0     		beq	.L66
 562:uCOSII/Source/os_mutex.c ****              *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within T
 1028              		.loc 1 562 14 is_stmt 1 view .LVU390
 1029 012c 2146     		mov	r1, r4
 1030 012e FFF7FEFF 		bl	OS_EventTaskRemove
 1031              	.LVL86:
 563:uCOSII/Source/os_mutex.c ****              break;
 1032              		.loc 1 563 14 view .LVU391
 563:uCOSII/Source/os_mutex.c ****              break;
 1033              		.loc 1 563 20 is_stmt 0 view .LVU392
 1034 0132 0A23     		movs	r3, #10
 1035 0134 2B70     		strb	r3, [r5]
 564:uCOSII/Source/os_mutex.c ****     }
 1036              		.loc 1 564 14 is_stmt 1 view .LVU393
 1037 0136 46E0     		b	.L68
 1038              	.LVL87:
 1039              	.L73:
 483:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task    
 1040              		.loc 1 483 9 view .LVU394
 483:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task    
 1041              		.loc 1 483 28 is_stmt 0 view .LVU395
 1042 0138 03F47F43 		and	r3, r3, #65280
 1043 013c 2381     		strh	r3, [r4, #8]	@ movhi
 484:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB   
 1044              		.loc 1 484 9 is_stmt 1 view .LVU396
 484:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB   
 1045              		.loc 1 484 39 is_stmt 0 view .LVU397
 1046 013e 2C49     		ldr	r1, .L76+8
 1047 0140 0968     		ldr	r1, [r1]
 1048 0142 91F83600 		ldrb	r0, [r1, #54]	@ zero_extendqisi2
 1049              	.LVL88:
 484:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB   
 1050              		.loc 1 484 28 view .LVU398
 1051 0146 0343     		orrs	r3, r3, r0
 1052 0148 2381     		strh	r3, [r4, #8]	@ movhi
 485:uCOSII/Source/os_mutex.c ****         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
 1053              		.loc 1 485 9 is_stmt 1 view .LVU399
 485:uCOSII/Source/os_mutex.c ****         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
ARM GAS  /tmp/ccyWPqe2.s 			page 39


 1054              		.loc 1 485 29 is_stmt 0 view .LVU400
 1055 014a 6160     		str	r1, [r4, #4]
 486:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio .
 1056              		.loc 1 486 9 is_stmt 1 view .LVU401
 486:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio .
 1057              		.loc 1 486 12 is_stmt 0 view .LVU402
 1058 014c FF2A     		cmp	r2, #255
 1059 014e 03D0     		beq	.L58
 487:uCOSII/Source/os_mutex.c ****              OS_EXIT_CRITICAL();                           /*      ... than current task!          
 1060              		.loc 1 487 22 discriminator 1 view .LVU403
 1061 0150 91F83630 		ldrb	r3, [r1, #54]	@ zero_extendqisi2
 486:uCOSII/Source/os_mutex.c ****             (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio .
 1062              		.loc 1 486 45 discriminator 1 view .LVU404
 1063 0154 9342     		cmp	r3, r2
 1064 0156 05D9     		bls	.L75
 1065              	.L58:
 491:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_NONE;
 1066              		.loc 1 491 14 is_stmt 1 view .LVU405
 1067 0158 3846     		mov	r0, r7
 1068 015a FFF7FEFF 		bl	OS_CPU_SR_Restore
 1069              	.LVL89:
 491:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_NONE;
 1070              		.loc 1 491 32 view .LVU406
 492:uCOSII/Source/os_mutex.c ****         }
 1071              		.loc 1 492 13 view .LVU407
 492:uCOSII/Source/os_mutex.c ****         }
 1072              		.loc 1 492 19 is_stmt 0 view .LVU408
 1073 015e 0023     		movs	r3, #0
 1074 0160 2B70     		strb	r3, [r5]
 494:uCOSII/Source/os_mutex.c ****     }
 1075              		.loc 1 494 9 is_stmt 1 view .LVU409
 1076 0162 55E7     		b	.L52
 1077              	.LVL90:
 1078              	.L75:
 488:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_PCP_LOWER;
 1079              		.loc 1 488 14 view .LVU410
 1080 0164 3846     		mov	r0, r7
 1081 0166 FFF7FEFF 		bl	OS_CPU_SR_Restore
 1082              	.LVL91:
 488:uCOSII/Source/os_mutex.c ****             *perr = OS_ERR_PCP_LOWER;
 1083              		.loc 1 488 32 view .LVU411
 489:uCOSII/Source/os_mutex.c ****         } else {
 1084              		.loc 1 489 13 view .LVU412
 489:uCOSII/Source/os_mutex.c ****         } else {
 1085              		.loc 1 489 19 is_stmt 0 view .LVU413
 1086 016a 7823     		movs	r3, #120
 1087 016c 2B70     		strb	r3, [r5]
 1088 016e 4FE7     		b	.L52
 1089              	.LVL92:
 1090              	.L61:
 509:uCOSII/Source/os_mutex.c ****                     if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list   
 1091              		.loc 1 509 21 is_stmt 1 view .LVU414
 509:uCOSII/Source/os_mutex.c ****                     if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list   
 1092              		.loc 1 509 29 is_stmt 0 view .LVU415
 1093 0170 D3F81C80 		ldr	r8, [r3, #28]
 1094              	.LVL93:
 510:uCOSII/Source/os_mutex.c ****                         y = ptcb->OSTCBY;
ARM GAS  /tmp/ccyWPqe2.s 			page 40


 1095              		.loc 1 510 21 is_stmt 1 view .LVU416
 510:uCOSII/Source/os_mutex.c ****                         y = ptcb->OSTCBY;
 1096              		.loc 1 510 24 is_stmt 0 view .LVU417
 1097 0174 B8F1000F 		cmp	r8, #0
 1098 0178 8BD0     		beq	.L62
 511:uCOSII/Source/os_mutex.c ****                         pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
 1099              		.loc 1 511 25 is_stmt 1 view .LVU418
 512:uCOSII/Source/os_mutex.c ****                         if (pevent2->OSEventTbl[y] == 0u) {
 1100              		.loc 1 512 25 view .LVU419
 512:uCOSII/Source/os_mutex.c ****                         if (pevent2->OSEventTbl[y] == 0u) {
 1101              		.loc 1 512 48 is_stmt 0 view .LVU420
 1102 017a 4044     		add	r0, r0, r8
 1103              	.LVL94:
 512:uCOSII/Source/os_mutex.c ****                         if (pevent2->OSEventTbl[y] == 0u) {
 1104              		.loc 1 512 48 view .LVU421
 1105 017c C17A     		ldrb	r1, [r0, #11]	@ zero_extendqisi2
 1106 017e 21EA0C01 		bic	r1, r1, ip
 1107 0182 C172     		strb	r1, [r0, #11]
 1108              	.LVL95:
 513:uCOSII/Source/os_mutex.c ****                             pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 1109              		.loc 1 513 25 is_stmt 1 view .LVU422
 513:uCOSII/Source/os_mutex.c ****                             pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 1110              		.loc 1 513 28 is_stmt 0 view .LVU423
 1111 0184 0029     		cmp	r1, #0
 1112 0186 84D1     		bne	.L62
 514:uCOSII/Source/os_mutex.c ****                         }
 1113              		.loc 1 514 29 is_stmt 1 view .LVU424
 514:uCOSII/Source/os_mutex.c ****                         }
 1114              		.loc 1 514 66 is_stmt 0 view .LVU425
 1115 0188 93F83AC0 		ldrb	ip, [r3, #58]	@ zero_extendqisi2
 514:uCOSII/Source/os_mutex.c ****                         }
 1116              		.loc 1 514 49 view .LVU426
 1117 018c 98F80A00 		ldrb	r0, [r8, #10]	@ zero_extendqisi2
 1118 0190 20EA0C00 		bic	r0, r0, ip
 1119 0194 88F80A00 		strb	r0, [r8, #10]
 517:uCOSII/Source/os_mutex.c ****                 }
 1120              		.loc 1 517 25 view .LVU427
 1121 0198 8E46     		mov	lr, r1
 1122 019a 7AE7     		b	.L62
 1123              	.LVL96:
 1124              	.L69:
 507:uCOSII/Source/os_mutex.c ****                 } else {
 1125              		.loc 1 507 25 view .LVU428
 1126 019c 4FF0010E 		mov	lr, #1
 1127 01a0 77E7     		b	.L62
 1128              	.LVL97:
 1129              	.L74:
 531:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 1130              		.loc 1 531 21 is_stmt 1 view .LVU429
 531:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 1131              		.loc 1 531 44 is_stmt 0 view .LVU430
 1132 01a2 DFF85480 		ldr	r8, .L76+16
 1133 01a6 98F800E0 		ldrb	lr, [r8]	@ zero_extendqisi2
 1134              	.LVL98:
 531:uCOSII/Source/os_mutex.c ****                     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 1135              		.loc 1 531 44 view .LVU431
 1136 01aa 40EA0E00 		orr	r0, r0, lr
ARM GAS  /tmp/ccyWPqe2.s 			page 41


 1137 01ae 88F80000 		strb	r0, [r8]
 532:uCOSII/Source/os_mutex.c ****                 } else {
 1138              		.loc 1 532 21 is_stmt 1 view .LVU432
 532:uCOSII/Source/os_mutex.c ****                 } else {
 1139              		.loc 1 532 44 is_stmt 0 view .LVU433
 1140 01b2 1048     		ldr	r0, .L76+12
 1141 01b4 10F80CE0 		ldrb	lr, [r0, ip]	@ zero_extendqisi2
 1142 01b8 41EA0E01 		orr	r1, r1, lr
 1143 01bc 00F80C10 		strb	r1, [r0, ip]
 1144 01c0 90E7     		b	.L64
 1145              	.LVL99:
 1146              	.L65:
 553:uCOSII/Source/os_mutex.c ****              break;
 1147              		.loc 1 553 14 is_stmt 1 view .LVU434
 553:uCOSII/Source/os_mutex.c ****              break;
 1148              		.loc 1 553 20 is_stmt 0 view .LVU435
 1149 01c2 0023     		movs	r3, #0
 1150 01c4 2B70     		strb	r3, [r5]
 554:uCOSII/Source/os_mutex.c **** 
 1151              		.loc 1 554 14 is_stmt 1 view .LVU436
 1152              	.L68:
 566:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                        
 1153              		.loc 1 566 5 view .LVU437
 566:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                        
 1154              		.loc 1 566 13 is_stmt 0 view .LVU438
 1155 01c6 0A4B     		ldr	r3, .L76+8
 1156 01c8 1B68     		ldr	r3, [r3]
 566:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                        
 1157              		.loc 1 566 34 view .LVU439
 1158 01ca 0022     		movs	r2, #0
 1159 01cc 83F83420 		strb	r2, [r3, #52]
 567:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                      
 1160              		.loc 1 567 5 is_stmt 1 view .LVU440
 567:uCOSII/Source/os_mutex.c ****     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                      
 1161              		.loc 1 567 34 is_stmt 0 view .LVU441
 1162 01d0 83F83520 		strb	r2, [r3, #53]
 568:uCOSII/Source/os_mutex.c **** #if (OS_EVENT_MULTI_EN > 0u)
 1163              		.loc 1 568 5 is_stmt 1 view .LVU442
 568:uCOSII/Source/os_mutex.c **** #if (OS_EVENT_MULTI_EN > 0u)
 1164              		.loc 1 568 34 is_stmt 0 view .LVU443
 1165 01d4 DA61     		str	r2, [r3, #28]
 570:uCOSII/Source/os_mutex.c **** #endif
 1166              		.loc 1 570 5 is_stmt 1 view .LVU444
 570:uCOSII/Source/os_mutex.c **** #endif
 1167              		.loc 1 570 34 is_stmt 0 view .LVU445
 1168 01d6 1A62     		str	r2, [r3, #32]
 572:uCOSII/Source/os_mutex.c **** }
 1169              		.loc 1 572 5 is_stmt 1 view .LVU446
 1170 01d8 3046     		mov	r0, r6
 1171 01da FFF7FEFF 		bl	OS_CPU_SR_Restore
 1172              	.LVL100:
 572:uCOSII/Source/os_mutex.c **** }
 1173              		.loc 1 572 23 view .LVU447
 1174 01de 17E7     		b	.L52
 1175              	.L66:
 557:uCOSII/Source/os_mutex.c ****              break;
 1176              		.loc 1 557 14 view .LVU448
ARM GAS  /tmp/ccyWPqe2.s 			page 42


 557:uCOSII/Source/os_mutex.c ****              break;
 1177              		.loc 1 557 20 is_stmt 0 view .LVU449
 1178 01e0 0E23     		movs	r3, #14
 1179 01e2 2B70     		strb	r3, [r5]
 558:uCOSII/Source/os_mutex.c **** 
 1180              		.loc 1 558 14 is_stmt 1 view .LVU450
 1181 01e4 EFE7     		b	.L68
 1182              	.L77:
 1183 01e6 00BF     		.align	2
 1184              	.L76:
 1185 01e8 00000000 		.word	OSIntNesting
 1186 01ec 00000000 		.word	OSLockNesting
 1187 01f0 00000000 		.word	OSTCBCur
 1188 01f4 00000000 		.word	OSRdyTbl
 1189 01f8 00000000 		.word	OSRdyGrp
 1190 01fc 00000000 		.word	OSTCBPrioTbl
 1191              		.cfi_endproc
 1192              	.LFE3:
 1194              		.section	.text.OSMutexPost,"ax",%progbits
 1195              		.align	1
 1196              		.global	OSMutexPost
 1197              		.syntax unified
 1198              		.thumb
 1199              		.thumb_func
 1200              		.fpu fpv4-sp-d16
 1202              	OSMutexPost:
 1203              	.LVL101:
 1204              	.LFB4:
 600:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                   /* Priority ceiling priority                 
 1205              		.loc 1 600 1 view -0
 1206              		.cfi_startproc
 1207              		@ args = 0, pretend = 0, frame = 0
 1208              		@ frame_needed = 0, uses_anonymous_args = 0
 600:uCOSII/Source/os_mutex.c ****     INT8U      pcp;                                   /* Priority ceiling priority                 
 1209              		.loc 1 600 1 is_stmt 0 view .LVU452
 1210 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1211              	.LCFI6:
 1212              		.cfi_def_cfa_offset 24
 1213              		.cfi_offset 4, -24
 1214              		.cfi_offset 5, -20
 1215              		.cfi_offset 6, -16
 1216              		.cfi_offset 7, -12
 1217              		.cfi_offset 8, -8
 1218              		.cfi_offset 14, -4
 601:uCOSII/Source/os_mutex.c ****     INT8U      prio;
 1219              		.loc 1 601 5 is_stmt 1 view .LVU453
 602:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register  
 1220              		.loc 1 602 5 view .LVU454
 604:uCOSII/Source/os_mutex.c **** #endif
 1221              		.loc 1 604 5 view .LVU455
 1222              	.LVL102:
 609:uCOSII/Source/os_mutex.c ****         return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR          
 1223              		.loc 1 609 5 view .LVU456
 609:uCOSII/Source/os_mutex.c ****         return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR          
 1224              		.loc 1 609 22 is_stmt 0 view .LVU457
 1225 0004 2D4B     		ldr	r3, .L92
 1226 0006 1E78     		ldrb	r6, [r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccyWPqe2.s 			page 43


 609:uCOSII/Source/os_mutex.c ****         return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR          
 1227              		.loc 1 609 8 view .LVU458
 1228 0008 002E     		cmp	r6, #0
 1229 000a 54D1     		bne	.L85
 1230 000c 0446     		mov	r4, r0
 617:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 1231              		.loc 1 617 5 is_stmt 1 view .LVU459
 617:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 1232              		.loc 1 617 15 is_stmt 0 view .LVU460
 1233 000e 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 617:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 1234              		.loc 1 617 8 view .LVU461
 1235 0010 042B     		cmp	r3, #4
 1236 0012 03D0     		beq	.L88
 618:uCOSII/Source/os_mutex.c ****     }
 1237              		.loc 1 618 16 view .LVU462
 1238 0014 0125     		movs	r5, #1
 1239              	.LVL103:
 1240              	.L79:
 654:uCOSII/Source/os_mutex.c **** /*$PAGE*/
 1241              		.loc 1 654 1 view .LVU463
 1242 0016 2846     		mov	r0, r5
 1243 0018 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1244              	.LVL104:
 1245              	.L88:
 620:uCOSII/Source/os_mutex.c ****     pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex    
 1246              		.loc 1 620 5 is_stmt 1 view .LVU464
 1247 001c FFF7FEFF 		bl	OS_CPU_SR_Save
 1248              	.LVL105:
 620:uCOSII/Source/os_mutex.c ****     pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex    
 1249              		.loc 1 620 5 is_stmt 0 view .LVU465
 1250 0020 0746     		mov	r7, r0
 1251              	.LVL106:
 620:uCOSII/Source/os_mutex.c ****     pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex    
 1252              		.loc 1 620 24 is_stmt 1 view .LVU466
 621:uCOSII/Source/os_mutex.c ****     prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority  
 1253              		.loc 1 621 5 view .LVU467
 621:uCOSII/Source/os_mutex.c ****     prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority  
 1254              		.loc 1 621 26 is_stmt 0 view .LVU468
 1255 0022 2189     		ldrh	r1, [r4, #8]
 621:uCOSII/Source/os_mutex.c ****     prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority  
 1256              		.loc 1 621 10 view .LVU469
 1257 0024 4FEA1128 		lsr	r8, r1, #8
 1258              	.LVL107:
 622:uCOSII/Source/os_mutex.c ****     if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX        
 1259              		.loc 1 622 5 is_stmt 1 view .LVU470
 622:uCOSII/Source/os_mutex.c ****     if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX        
 1260              		.loc 1 622 10 is_stmt 0 view .LVU471
 1261 0028 C9B2     		uxtb	r1, r1
 1262              	.LVL108:
 623:uCOSII/Source/os_mutex.c ****         OS_EXIT_CRITICAL();
 1263              		.loc 1 623 5 is_stmt 1 view .LVU472
 623:uCOSII/Source/os_mutex.c ****         OS_EXIT_CRITICAL();
 1264              		.loc 1 623 37 is_stmt 0 view .LVU473
 1265 002a 6368     		ldr	r3, [r4, #4]
 623:uCOSII/Source/os_mutex.c ****         OS_EXIT_CRITICAL();
 1266              		.loc 1 623 18 view .LVU474
ARM GAS  /tmp/ccyWPqe2.s 			page 44


 1267 002c 244A     		ldr	r2, .L92+4
 1268 002e 1068     		ldr	r0, [r2]
 1269              	.LVL109:
 623:uCOSII/Source/os_mutex.c ****         OS_EXIT_CRITICAL();
 1270              		.loc 1 623 8 view .LVU475
 1271 0030 8342     		cmp	r3, r0
 1272 0032 27D1     		bne	.L89
 627:uCOSII/Source/os_mutex.c ****         if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priori
 1273              		.loc 1 627 5 is_stmt 1 view .LVU476
 627:uCOSII/Source/os_mutex.c ****         if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priori
 1274              		.loc 1 627 8 is_stmt 0 view .LVU477
 1275 0034 B8F1FF0F 		cmp	r8, #255
 1276 0038 07D0     		beq	.L81
 628:uCOSII/Source/os_mutex.c ****             OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority      
 1277              		.loc 1 628 9 is_stmt 1 view .LVU478
 628:uCOSII/Source/os_mutex.c ****             OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority      
 1278              		.loc 1 628 21 is_stmt 0 view .LVU479
 1279 003a 90F83630 		ldrb	r3, [r0, #54]	@ zero_extendqisi2
 628:uCOSII/Source/os_mutex.c ****             OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority      
 1280              		.loc 1 628 12 view .LVU480
 1281 003e 4345     		cmp	r3, r8
 1282 0040 25D0     		beq	.L90
 1283              	.LVL110:
 1284              	.L82:
 631:uCOSII/Source/os_mutex.c ****     }
 1285              		.loc 1 631 9 is_stmt 1 view .LVU481
 631:uCOSII/Source/os_mutex.c ****     }
 1286              		.loc 1 631 27 is_stmt 0 view .LVU482
 1287 0042 204B     		ldr	r3, .L92+8
 1288 0044 0122     		movs	r2, #1
 1289 0046 43F82820 		str	r2, [r3, r8, lsl #2]
 1290              	.L81:
 633:uCOSII/Source/os_mutex.c ****                                                       /* Yes, Make HPT waiting for mutex ready     
 1291              		.loc 1 633 5 is_stmt 1 view .LVU483
 633:uCOSII/Source/os_mutex.c ****                                                       /* Yes, Make HPT waiting for mutex ready     
 1292              		.loc 1 633 15 is_stmt 0 view .LVU484
 1293 004a A57A     		ldrb	r5, [r4, #10]	@ zero_extendqisi2
 633:uCOSII/Source/os_mutex.c ****                                                       /* Yes, Make HPT waiting for mutex ready     
 1294              		.loc 1 633 8 view .LVU485
 1295 004c 4DB3     		cbz	r5, .L83
 635:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner   
 1296              		.loc 1 635 9 is_stmt 1 view .LVU486
 635:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner   
 1297              		.loc 1 635 31 is_stmt 0 view .LVU487
 1298 004e 0023     		movs	r3, #0
 1299 0050 1022     		movs	r2, #16
 1300 0052 1946     		mov	r1, r3
 1301 0054 2046     		mov	r0, r4
 1302 0056 FFF7FEFF 		bl	OS_EventTaskRdy
 1303              	.LVL111:
 636:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= prio;
 1304              		.loc 1 636 9 is_stmt 1 view .LVU488
 636:uCOSII/Source/os_mutex.c ****         pevent->OSEventCnt |= prio;
 1305              		.loc 1 636 28 is_stmt 0 view .LVU489
 1306 005a 2389     		ldrh	r3, [r4, #8]
 1307 005c 03F47F43 		and	r3, r3, #65280
 637:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB     
ARM GAS  /tmp/ccyWPqe2.s 			page 45


 1308              		.loc 1 637 9 is_stmt 1 view .LVU490
 637:uCOSII/Source/os_mutex.c ****         pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB     
 1309              		.loc 1 637 28 is_stmt 0 view .LVU491
 1310 0060 0343     		orrs	r3, r3, r0
 1311 0062 2381     		strh	r3, [r4, #8]	@ movhi
 638:uCOSII/Source/os_mutex.c ****         if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
 1312              		.loc 1 638 9 is_stmt 1 view .LVU492
 638:uCOSII/Source/os_mutex.c ****         if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
 1313              		.loc 1 638 43 is_stmt 0 view .LVU493
 1314 0064 174B     		ldr	r3, .L92+8
 1315 0066 53F82030 		ldr	r3, [r3, r0, lsl #2]
 638:uCOSII/Source/os_mutex.c ****         if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
 1316              		.loc 1 638 29 view .LVU494
 1317 006a 6360     		str	r3, [r4, #4]
 639:uCOSII/Source/os_mutex.c ****             (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...   
 1318              		.loc 1 639 9 is_stmt 1 view .LVU495
 639:uCOSII/Source/os_mutex.c ****             (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...   
 1319              		.loc 1 639 12 is_stmt 0 view .LVU496
 1320 006c B8F1FF0F 		cmp	r8, #255
 1321 0070 01D0     		beq	.L84
 639:uCOSII/Source/os_mutex.c ****             (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...   
 1322              		.loc 1 639 46 discriminator 1 view .LVU497
 1323 0072 8045     		cmp	r8, r0
 1324 0074 0ED2     		bcs	.L91
 1325              	.L84:
 645:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 1326              		.loc 1 645 13 is_stmt 1 view .LVU498
 1327 0076 3846     		mov	r0, r7
 1328              	.LVL112:
 645:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 1329              		.loc 1 645 13 is_stmt 0 view .LVU499
 1330 0078 FFF7FEFF 		bl	OS_CPU_SR_Restore
 1331              	.LVL113:
 645:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 1332              		.loc 1 645 31 is_stmt 1 view .LVU500
 646:uCOSII/Source/os_mutex.c ****             return (OS_ERR_NONE);
 1333              		.loc 1 646 13 view .LVU501
 1334 007c FFF7FEFF 		bl	OS_Sched
 1335              	.LVL114:
 647:uCOSII/Source/os_mutex.c ****         }
 1336              		.loc 1 647 13 view .LVU502
 647:uCOSII/Source/os_mutex.c ****         }
 1337              		.loc 1 647 20 is_stmt 0 view .LVU503
 1338 0080 3546     		mov	r5, r6
 1339 0082 C8E7     		b	.L79
 1340              	.LVL115:
 1341              	.L89:
 624:uCOSII/Source/os_mutex.c ****         return (OS_ERR_NOT_MUTEX_OWNER);
 1342              		.loc 1 624 9 is_stmt 1 view .LVU504
 1343 0084 3846     		mov	r0, r7
 1344 0086 FFF7FEFF 		bl	OS_CPU_SR_Restore
 1345              	.LVL116:
 624:uCOSII/Source/os_mutex.c ****         return (OS_ERR_NOT_MUTEX_OWNER);
 1346              		.loc 1 624 27 view .LVU505
 625:uCOSII/Source/os_mutex.c ****     }
 1347              		.loc 1 625 9 view .LVU506
 625:uCOSII/Source/os_mutex.c ****     }
ARM GAS  /tmp/ccyWPqe2.s 			page 46


 1348              		.loc 1 625 16 is_stmt 0 view .LVU507
 1349 008a 6425     		movs	r5, #100
 1350 008c C3E7     		b	.L79
 1351              	.LVL117:
 1352              	.L90:
 629:uCOSII/Source/os_mutex.c ****         }
 1353              		.loc 1 629 13 is_stmt 1 view .LVU508
 1354 008e FFF7FEFF 		bl	OSMutex_RdyAtPrio
 1355              	.LVL118:
 629:uCOSII/Source/os_mutex.c ****         }
 1356              		.loc 1 629 13 is_stmt 0 view .LVU509
 1357 0092 D6E7     		b	.L82
 1358              	.LVL119:
 1359              	.L91:
 641:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 1360              		.loc 1 641 13 is_stmt 1 view .LVU510
 1361 0094 3846     		mov	r0, r7
 1362              	.LVL120:
 641:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 1363              		.loc 1 641 13 is_stmt 0 view .LVU511
 1364 0096 FFF7FEFF 		bl	OS_CPU_SR_Restore
 1365              	.LVL121:
 641:uCOSII/Source/os_mutex.c ****             OS_Sched();                               /*      Find highest priority task ready to r
 1366              		.loc 1 641 31 is_stmt 1 view .LVU512
 642:uCOSII/Source/os_mutex.c ****             return (OS_ERR_PCP_LOWER);
 1367              		.loc 1 642 13 view .LVU513
 1368 009a FFF7FEFF 		bl	OS_Sched
 1369              	.LVL122:
 643:uCOSII/Source/os_mutex.c ****         } else {
 1370              		.loc 1 643 13 view .LVU514
 643:uCOSII/Source/os_mutex.c ****         } else {
 1371              		.loc 1 643 20 is_stmt 0 view .LVU515
 1372 009e 7825     		movs	r5, #120
 1373 00a0 B9E7     		b	.L79
 1374              	.L83:
 650:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;
 1375              		.loc 1 650 5 is_stmt 1 view .LVU516
 650:uCOSII/Source/os_mutex.c ****     pevent->OSEventPtr  = (void *)0;
 1376              		.loc 1 650 24 is_stmt 0 view .LVU517
 1377 00a2 2389     		ldrh	r3, [r4, #8]
 1378 00a4 43F0FF03 		orr	r3, r3, #255
 1379 00a8 2381     		strh	r3, [r4, #8]	@ movhi
 651:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 1380              		.loc 1 651 5 is_stmt 1 view .LVU518
 651:uCOSII/Source/os_mutex.c ****     OS_EXIT_CRITICAL();
 1381              		.loc 1 651 25 is_stmt 0 view .LVU519
 1382 00aa 0023     		movs	r3, #0
 1383 00ac 6360     		str	r3, [r4, #4]
 652:uCOSII/Source/os_mutex.c ****     return (OS_ERR_NONE);
 1384              		.loc 1 652 5 is_stmt 1 view .LVU520
 1385 00ae 3846     		mov	r0, r7
 1386 00b0 FFF7FEFF 		bl	OS_CPU_SR_Restore
 1387              	.LVL123:
 652:uCOSII/Source/os_mutex.c ****     return (OS_ERR_NONE);
 1388              		.loc 1 652 23 view .LVU521
 653:uCOSII/Source/os_mutex.c **** }
 1389              		.loc 1 653 5 view .LVU522
ARM GAS  /tmp/ccyWPqe2.s 			page 47


 653:uCOSII/Source/os_mutex.c **** }
 1390              		.loc 1 653 12 is_stmt 0 view .LVU523
 1391 00b4 AFE7     		b	.L79
 1392              	.LVL124:
 1393              	.L85:
 610:uCOSII/Source/os_mutex.c ****     }
 1394              		.loc 1 610 16 view .LVU524
 1395 00b6 0525     		movs	r5, #5
 1396 00b8 ADE7     		b	.L79
 1397              	.L93:
 1398 00ba 00BF     		.align	2
 1399              	.L92:
 1400 00bc 00000000 		.word	OSIntNesting
 1401 00c0 00000000 		.word	OSTCBCur
 1402 00c4 00000000 		.word	OSTCBPrioTbl
 1403              		.cfi_endproc
 1404              	.LFE4:
 1406              		.section	.text.OSMutexQuery,"ax",%progbits
 1407              		.align	1
 1408              		.global	OSMutexQuery
 1409              		.syntax unified
 1410              		.thumb
 1411              		.thumb_func
 1412              		.fpu fpv4-sp-d16
 1414              	OSMutexQuery:
 1415              	.LVL125:
 1416              	.LFB5:
 677:uCOSII/Source/os_mutex.c ****     INT8U       i;
 1417              		.loc 1 677 1 is_stmt 1 view -0
 1418              		.cfi_startproc
 1419              		@ args = 0, pretend = 0, frame = 0
 1420              		@ frame_needed = 0, uses_anonymous_args = 0
 677:uCOSII/Source/os_mutex.c ****     INT8U       i;
 1421              		.loc 1 677 1 is_stmt 0 view .LVU526
 1422 0000 70B5     		push	{r4, r5, r6, lr}
 1423              	.LCFI7:
 1424              		.cfi_def_cfa_offset 16
 1425              		.cfi_offset 4, -16
 1426              		.cfi_offset 5, -12
 1427              		.cfi_offset 6, -8
 1428              		.cfi_offset 14, -4
 678:uCOSII/Source/os_mutex.c ****     OS_PRIO    *psrc;
 1429              		.loc 1 678 5 is_stmt 1 view .LVU527
 679:uCOSII/Source/os_mutex.c ****     OS_PRIO    *pdest;
 1430              		.loc 1 679 5 view .LVU528
 680:uCOSII/Source/os_mutex.c **** #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register       
 1431              		.loc 1 680 5 view .LVU529
 682:uCOSII/Source/os_mutex.c **** #endif
 1432              		.loc 1 682 5 view .LVU530
 1433              	.LVL126:
 687:uCOSII/Source/os_mutex.c ****         return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR    
 1434              		.loc 1 687 5 view .LVU531
 687:uCOSII/Source/os_mutex.c ****         return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR    
 1435              		.loc 1 687 22 is_stmt 0 view .LVU532
 1436 0002 164B     		ldr	r3, .L105
 1437 0004 1E78     		ldrb	r6, [r3]	@ zero_extendqisi2
 687:uCOSII/Source/os_mutex.c ****         return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR    
ARM GAS  /tmp/ccyWPqe2.s 			page 48


 1438              		.loc 1 687 8 view .LVU533
 1439 0006 3EBB     		cbnz	r6, .L100
 1440 0008 0446     		mov	r4, r0
 1441 000a 0D46     		mov	r5, r1
 698:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 1442              		.loc 1 698 5 is_stmt 1 view .LVU534
 698:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 1443              		.loc 1 698 15 is_stmt 0 view .LVU535
 1444 000c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 698:uCOSII/Source/os_mutex.c ****         return (OS_ERR_EVENT_TYPE);
 1445              		.loc 1 698 8 view .LVU536
 1446 000e 042B     		cmp	r3, #4
 1447 0010 02D0     		beq	.L103
 699:uCOSII/Source/os_mutex.c ****     }
 1448              		.loc 1 699 16 view .LVU537
 1449 0012 0126     		movs	r6, #1
 1450              	.LVL127:
 1451              	.L95:
 717:uCOSII/Source/os_mutex.c **** #endif                                                     /* OS_MUTEX_QUERY_EN                    
 1452              		.loc 1 717 1 view .LVU538
 1453 0014 3046     		mov	r0, r6
 1454 0016 70BD     		pop	{r4, r5, r6, pc}
 1455              	.LVL128:
 1456              	.L103:
 701:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
 1457              		.loc 1 701 5 is_stmt 1 view .LVU539
 1458 0018 FFF7FEFF 		bl	OS_CPU_SR_Save
 1459              	.LVL129:
 701:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
 1460              		.loc 1 701 24 view .LVU540
 702:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 1461              		.loc 1 702 5 view .LVU541
 702:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 1462              		.loc 1 702 47 is_stmt 0 view .LVU542
 1463 001c 2389     		ldrh	r3, [r4, #8]
 702:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 1464              		.loc 1 702 33 view .LVU543
 1465 001e 1B0A     		lsrs	r3, r3, #8
 702:uCOSII/Source/os_mutex.c ****     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 1466              		.loc 1 702 31 view .LVU544
 1467 0020 EB72     		strb	r3, [r5, #11]
 703:uCOSII/Source/os_mutex.c ****     if (p_mutex_data->OSOwnerPrio == 0xFFu) {
 1468              		.loc 1 703 5 is_stmt 1 view .LVU545
 703:uCOSII/Source/os_mutex.c ****     if (p_mutex_data->OSOwnerPrio == 0xFFu) {
 1469              		.loc 1 703 33 is_stmt 0 view .LVU546
 1470 0022 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 703:uCOSII/Source/os_mutex.c ****     if (p_mutex_data->OSOwnerPrio == 0xFFu) {
 1471              		.loc 1 703 31 view .LVU547
 1472 0024 AB72     		strb	r3, [r5, #10]
 704:uCOSII/Source/os_mutex.c ****         p_mutex_data->OSValue = OS_TRUE;
 1473              		.loc 1 704 5 is_stmt 1 view .LVU548
 704:uCOSII/Source/os_mutex.c ****         p_mutex_data->OSValue = OS_TRUE;
 1474              		.loc 1 704 8 is_stmt 0 view .LVU549
 1475 0026 FF2B     		cmp	r3, #255
 1476 0028 08D0     		beq	.L104
 707:uCOSII/Source/os_mutex.c ****     }
 1477              		.loc 1 707 9 is_stmt 1 view .LVU550
ARM GAS  /tmp/ccyWPqe2.s 			page 49


 707:uCOSII/Source/os_mutex.c ****     }
 1478              		.loc 1 707 31 is_stmt 0 view .LVU551
 1479 002a 0023     		movs	r3, #0
 1480 002c 6B72     		strb	r3, [r5, #9]
 1481              	.L97:
 709:uCOSII/Source/os_mutex.c ****     psrc                      = &pevent->OSEventTbl[0];
 1482              		.loc 1 709 5 is_stmt 1 view .LVU552
 709:uCOSII/Source/os_mutex.c ****     psrc                      = &pevent->OSEventTbl[0];
 1483              		.loc 1 709 39 is_stmt 0 view .LVU553
 1484 002e A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 709:uCOSII/Source/os_mutex.c ****     psrc                      = &pevent->OSEventTbl[0];
 1485              		.loc 1 709 31 view .LVU554
 1486 0030 2B72     		strb	r3, [r5, #8]
 710:uCOSII/Source/os_mutex.c ****     pdest                     = &p_mutex_data->OSEventTbl[0];
 1487              		.loc 1 710 5 is_stmt 1 view .LVU555
 710:uCOSII/Source/os_mutex.c ****     pdest                     = &p_mutex_data->OSEventTbl[0];
 1488              		.loc 1 710 31 is_stmt 0 view .LVU556
 1489 0032 04F10B03 		add	r3, r4, #11
 1490              	.LVL130:
 711:uCOSII/Source/os_mutex.c ****     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
 1491              		.loc 1 711 5 is_stmt 1 view .LVU557
 711:uCOSII/Source/os_mutex.c ****     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
 1492              		.loc 1 711 31 is_stmt 0 view .LVU558
 1493 0036 2946     		mov	r1, r5
 1494              	.LVL131:
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1495              		.loc 1 712 5 is_stmt 1 view .LVU559
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1496              		.loc 1 712 12 is_stmt 0 view .LVU560
 1497 0038 3246     		mov	r2, r6
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1498              		.loc 1 712 5 view .LVU561
 1499 003a 08E0     		b	.L98
 1500              	.LVL132:
 1501              	.L104:
 705:uCOSII/Source/os_mutex.c ****     } else {
 1502              		.loc 1 705 9 is_stmt 1 view .LVU562
 705:uCOSII/Source/os_mutex.c ****     } else {
 1503              		.loc 1 705 31 is_stmt 0 view .LVU563
 1504 003c 0123     		movs	r3, #1
 1505 003e 6B72     		strb	r3, [r5, #9]
 1506 0040 F5E7     		b	.L97
 1507              	.LVL133:
 1508              	.L99:
 713:uCOSII/Source/os_mutex.c ****     }
 1509              		.loc 1 713 9 is_stmt 1 discriminator 3 view .LVU564
 713:uCOSII/Source/os_mutex.c ****     }
 1510              		.loc 1 713 20 is_stmt 0 discriminator 3 view .LVU565
 1511 0042 13F8014B 		ldrb	r4, [r3], #1	@ zero_extendqisi2
 1512              	.LVL134:
 713:uCOSII/Source/os_mutex.c ****     }
 1513              		.loc 1 713 18 discriminator 3 view .LVU566
 1514 0046 01F8014B 		strb	r4, [r1], #1
 1515              	.LVL135:
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1516              		.loc 1 712 41 is_stmt 1 discriminator 3 view .LVU567
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
ARM GAS  /tmp/ccyWPqe2.s 			page 50


 1517              		.loc 1 712 42 is_stmt 0 discriminator 3 view .LVU568
 1518 004a 0132     		adds	r2, r2, #1
 1519              	.LVL136:
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1520              		.loc 1 712 42 discriminator 3 view .LVU569
 1521 004c D2B2     		uxtb	r2, r2
 1522              	.LVL137:
 1523              	.L98:
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1524              		.loc 1 712 18 is_stmt 1 discriminator 1 view .LVU570
 712:uCOSII/Source/os_mutex.c ****         *pdest++ = *psrc++;
 1525              		.loc 1 712 5 is_stmt 0 discriminator 1 view .LVU571
 1526 004e 072A     		cmp	r2, #7
 1527 0050 F7D9     		bls	.L99
 715:uCOSII/Source/os_mutex.c ****     return (OS_ERR_NONE);
 1528              		.loc 1 715 5 is_stmt 1 view .LVU572
 1529 0052 FFF7FEFF 		bl	OS_CPU_SR_Restore
 1530              	.LVL138:
 715:uCOSII/Source/os_mutex.c ****     return (OS_ERR_NONE);
 1531              		.loc 1 715 23 view .LVU573
 716:uCOSII/Source/os_mutex.c **** }
 1532              		.loc 1 716 5 view .LVU574
 716:uCOSII/Source/os_mutex.c **** }
 1533              		.loc 1 716 12 is_stmt 0 view .LVU575
 1534 0056 DDE7     		b	.L95
 1535              	.LVL139:
 1536              	.L100:
 688:uCOSII/Source/os_mutex.c ****     }
 1537              		.loc 1 688 16 view .LVU576
 1538 0058 0626     		movs	r6, #6
 1539 005a DBE7     		b	.L95
 1540              	.L106:
 1541              		.align	2
 1542              	.L105:
 1543 005c 00000000 		.word	OSIntNesting
 1544              		.cfi_endproc
 1545              	.LFE5:
 1547              		.text
 1548              	.Letext0:
 1549              		.file 2 "uCOSII/Ports/ARM-Cortex-M4/Generic/GNU/os_cpu.h"
 1550              		.file 3 "uCOSII/Include/ucos_ii.h"
ARM GAS  /tmp/ccyWPqe2.s 			page 51


DEFINED SYMBOLS
                            *ABS*:0000000000000000 os_mutex.c
     /tmp/ccyWPqe2.s:18     .text.OSMutex_RdyAtPrio:0000000000000000 $t
     /tmp/ccyWPqe2.s:25     .text.OSMutex_RdyAtPrio:0000000000000000 OSMutex_RdyAtPrio
     /tmp/ccyWPqe2.s:128    .text.OSMutex_RdyAtPrio:000000000000006c $d
     /tmp/ccyWPqe2.s:136    .text.OSMutexAccept:0000000000000000 $t
     /tmp/ccyWPqe2.s:143    .text.OSMutexAccept:0000000000000000 OSMutexAccept
     /tmp/ccyWPqe2.s:279    .text.OSMutexAccept:0000000000000074 $d
     /tmp/ccyWPqe2.s:285    .rodata.OSMutexCreate.str1.4:0000000000000000 $d
     /tmp/ccyWPqe2.s:289    .text.OSMutexCreate:0000000000000000 $t
     /tmp/ccyWPqe2.s:296    .text.OSMutexCreate:0000000000000000 OSMutexCreate
     /tmp/ccyWPqe2.s:441    .text.OSMutexCreate:0000000000000080 $d
     /tmp/ccyWPqe2.s:449    .text.OSMutexDel:0000000000000000 $t
     /tmp/ccyWPqe2.s:456    .text.OSMutexDel:0000000000000000 OSMutexDel
     /tmp/ccyWPqe2.s:750    .text.OSMutexDel:00000000000000f8 $d
     /tmp/ccyWPqe2.s:758    .text.OSMutexPend:0000000000000000 $t
     /tmp/ccyWPqe2.s:765    .text.OSMutexPend:0000000000000000 OSMutexPend
     /tmp/ccyWPqe2.s:1185   .text.OSMutexPend:00000000000001e8 $d
     /tmp/ccyWPqe2.s:1195   .text.OSMutexPost:0000000000000000 $t
     /tmp/ccyWPqe2.s:1202   .text.OSMutexPost:0000000000000000 OSMutexPost
     /tmp/ccyWPqe2.s:1400   .text.OSMutexPost:00000000000000bc $d
     /tmp/ccyWPqe2.s:1407   .text.OSMutexQuery:0000000000000000 $t
     /tmp/ccyWPqe2.s:1414   .text.OSMutexQuery:0000000000000000 OSMutexQuery
     /tmp/ccyWPqe2.s:1543   .text.OSMutexQuery:000000000000005c $d

UNDEFINED SYMBOLS
OSRdyTbl
OSRdyGrp
OSPrioCur
OSTCBPrioTbl
OS_CPU_SR_Save
OS_CPU_SR_Restore
OSIntNesting
OSTCBCur
OS_EventWaitListInit
OSEventFreeList
OS_EventTaskRdy
OS_Sched
OS_EventTaskWait
OS_EventTaskRemove
OSLockNesting
